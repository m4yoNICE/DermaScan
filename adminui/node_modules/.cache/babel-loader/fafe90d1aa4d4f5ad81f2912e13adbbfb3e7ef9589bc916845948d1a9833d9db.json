{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { getSide, getAlignment, getSideAxis } from '@floating-ui/utils';\nimport { ownerDocument } from '@base-ui-components/utils/owner';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useLatestRef } from '@base-ui-components/utils/useLatestRef';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { autoUpdate, flip, limitShift, offset, shift, useFloating, size, hide } from \"../floating-ui-react/index.js\";\nimport { useDirection } from \"../direction-provider/DirectionContext.js\";\nimport { arrow } from \"../floating-ui-react/middleware/arrow.js\";\nfunction getLogicalSide(sideParam, renderedSide, isRtl) {\n  const isLogicalSideParam = sideParam === 'inline-start' || sideParam === 'inline-end';\n  const logicalRight = isRtl ? 'inline-start' : 'inline-end';\n  const logicalLeft = isRtl ? 'inline-end' : 'inline-start';\n  return {\n    top: 'top',\n    right: isLogicalSideParam ? logicalRight : 'right',\n    bottom: 'bottom',\n    left: isLogicalSideParam ? logicalLeft : 'left'\n  }[renderedSide];\n}\nfunction getOffsetData(state, sideParam, isRtl) {\n  const {\n    rects,\n    placement\n  } = state;\n  const data = {\n    side: getLogicalSide(sideParam, getSide(placement), isRtl),\n    align: getAlignment(placement) || 'center',\n    anchor: {\n      width: rects.reference.width,\n      height: rects.reference.height\n    },\n    positioner: {\n      width: rects.floating.width,\n      height: rects.floating.height\n    }\n  };\n  return data;\n}\n/**\n * Provides standardized anchor positioning behavior for floating elements. Wraps Floating UI's\n * `useFloating` hook.\n */\nexport function useAnchorPositioning(params) {\n  const {\n    // Public parameters\n    anchor,\n    positionMethod = 'absolute',\n    side: sideParam = 'bottom',\n    sideOffset = 0,\n    align = 'center',\n    alignOffset = 0,\n    collisionBoundary,\n    collisionPadding: collisionPaddingParam = 5,\n    sticky = false,\n    arrowPadding = 5,\n    trackAnchor = true,\n    // Private parameters\n    keepMounted = false,\n    floatingRootContext,\n    mounted,\n    collisionAvoidance,\n    shiftCrossAxis = false,\n    nodeId,\n    adaptiveOrigin,\n    lazyFlip = false\n  } = params;\n  const [mountSide, setMountSide] = React.useState(null);\n  if (!mounted && mountSide !== null) {\n    setMountSide(null);\n  }\n  const collisionAvoidanceSide = collisionAvoidance.side || 'flip';\n  const collisionAvoidanceAlign = collisionAvoidance.align || 'flip';\n  const collisionAvoidanceFallbackAxisSide = collisionAvoidance.fallbackAxisSide || 'end';\n  const anchorFn = typeof anchor === 'function' ? anchor : undefined;\n  const anchorFnCallback = useEventCallback(anchorFn);\n  const anchorDep = anchorFn ? anchorFnCallback : anchor;\n  const anchorValueRef = useLatestRef(anchor);\n  const direction = useDirection();\n  const isRtl = direction === 'rtl';\n  const side = mountSide || {\n    top: 'top',\n    right: 'right',\n    bottom: 'bottom',\n    left: 'left',\n    'inline-end': isRtl ? 'left' : 'right',\n    'inline-start': isRtl ? 'right' : 'left'\n  }[sideParam];\n  const placement = align === 'center' ? side : `${side}-${align}`;\n  let collisionPadding = collisionPaddingParam;\n\n  // Create a bias to the preferred side.\n  // On iOS, when the mobile software keyboard opens, the input is exactly centered\n  // in the viewport, but this can cause it to flip to the top undesirably.\n  const bias = 1;\n  const biasTop = sideParam === 'bottom' ? bias : 0;\n  const biasBottom = sideParam === 'top' ? bias : 0;\n  const biasLeft = sideParam === 'right' ? bias : 0;\n  const biasRight = sideParam === 'left' ? bias : 0;\n  if (typeof collisionPadding === 'number') {\n    collisionPadding = {\n      top: collisionPadding + biasTop,\n      right: collisionPadding + biasRight,\n      bottom: collisionPadding + biasBottom,\n      left: collisionPadding + biasLeft\n    };\n  } else if (collisionPadding) {\n    collisionPadding = {\n      top: (collisionPadding.top || 0) + biasTop,\n      right: (collisionPadding.right || 0) + biasRight,\n      bottom: (collisionPadding.bottom || 0) + biasBottom,\n      left: (collisionPadding.left || 0) + biasLeft\n    };\n  }\n  const commonCollisionProps = {\n    boundary: collisionBoundary === 'clipping-ancestors' ? 'clippingAncestors' : collisionBoundary,\n    padding: collisionPadding\n  };\n\n  // Using a ref assumes that the arrow element is always present in the DOM for the lifetime of the\n  // popup. If this assumption ends up being false, we can switch to state to manage the arrow's\n  // presence.\n  const arrowRef = React.useRef(null);\n\n  // Keep these reactive if they're not functions\n  const sideOffsetRef = useLatestRef(sideOffset);\n  const alignOffsetRef = useLatestRef(alignOffset);\n  const sideOffsetDep = typeof sideOffset !== 'function' ? sideOffset : 0;\n  const alignOffsetDep = typeof alignOffset !== 'function' ? alignOffset : 0;\n  const middleware = [offset(state => {\n    const data = getOffsetData(state, sideParam, isRtl);\n    const sideAxis = typeof sideOffsetRef.current === 'function' ? sideOffsetRef.current(data) : sideOffsetRef.current;\n    const alignAxis = typeof alignOffsetRef.current === 'function' ? alignOffsetRef.current(data) : alignOffsetRef.current;\n    return {\n      mainAxis: sideAxis,\n      crossAxis: alignAxis,\n      alignmentAxis: alignAxis\n    };\n  }, [sideOffsetDep, alignOffsetDep, isRtl, sideParam])];\n  const shiftDisabled = collisionAvoidanceAlign === 'none' && collisionAvoidanceSide !== 'shift';\n  const crossAxisShiftEnabled = !shiftDisabled && (sticky || shiftCrossAxis || collisionAvoidanceSide === 'shift');\n  const flipMiddleware = collisionAvoidanceSide === 'none' ? null : flip({\n    ...commonCollisionProps,\n    // Ensure the popup flips if it's been limited by its --available-height and it resizes.\n    // Since the size() padding is smaller than the flip() padding, flip() will take precedence.\n    padding: {\n      top: collisionPadding.top + bias,\n      right: collisionPadding.right + bias,\n      bottom: collisionPadding.bottom + bias,\n      left: collisionPadding.left + bias\n    },\n    mainAxis: !shiftCrossAxis && collisionAvoidanceSide === 'flip',\n    crossAxis: collisionAvoidanceAlign === 'flip' ? 'alignment' : false,\n    fallbackAxisSideDirection: collisionAvoidanceFallbackAxisSide\n  });\n  const shiftMiddleware = shiftDisabled ? null : shift(data => {\n    const html = ownerDocument(data.elements.floating).documentElement;\n    return {\n      ...commonCollisionProps,\n      // Use the Layout Viewport to avoid shifting around when pinch-zooming\n      // for context menus.\n      rootBoundary: shiftCrossAxis ? {\n        x: 0,\n        y: 0,\n        width: html.clientWidth,\n        height: html.clientHeight\n      } : undefined,\n      mainAxis: collisionAvoidanceAlign !== 'none',\n      crossAxis: crossAxisShiftEnabled,\n      limiter: sticky || shiftCrossAxis ? undefined : limitShift(limitData => {\n        if (!arrowRef.current) {\n          return {};\n        }\n        const {\n          width,\n          height\n        } = arrowRef.current.getBoundingClientRect();\n        const sideAxis = getSideAxis(getSide(limitData.placement));\n        const arrowSize = sideAxis === 'y' ? width : height;\n        const offsetAmount = sideAxis === 'y' ? collisionPadding.left + collisionPadding.right : collisionPadding.top + collisionPadding.bottom;\n        return {\n          offset: arrowSize / 2 + offsetAmount / 2\n        };\n      })\n    };\n  }, [commonCollisionProps, sticky, shiftCrossAxis, collisionPadding, collisionAvoidanceAlign]);\n\n  // https://floating-ui.com/docs/flip#combining-with-shift\n  if (collisionAvoidanceSide === 'shift' || collisionAvoidanceAlign === 'shift' || align === 'center') {\n    middleware.push(shiftMiddleware, flipMiddleware);\n  } else {\n    middleware.push(flipMiddleware, shiftMiddleware);\n  }\n  middleware.push(size({\n    ...commonCollisionProps,\n    apply({\n      elements: {\n        floating\n      },\n      rects: {\n        reference\n      },\n      availableWidth,\n      availableHeight\n    }) {\n      Object.entries({\n        '--available-width': `${availableWidth}px`,\n        '--available-height': `${availableHeight}px`,\n        '--anchor-width': `${reference.width}px`,\n        '--anchor-height': `${reference.height}px`\n      }).forEach(([key, value]) => {\n        floating.style.setProperty(key, value);\n      });\n    }\n  }), arrow(() => ({\n    // `transform-origin` calculations rely on an element existing. If the arrow hasn't been set,\n    // we'll create a fake element.\n    element: arrowRef.current || document.createElement('div'),\n    padding: arrowPadding,\n    offsetParent: 'floating'\n  }), [arrowPadding]), hide(), {\n    name: 'transformOrigin',\n    fn(state) {\n      const {\n        elements,\n        middlewareData,\n        placement: renderedPlacement,\n        rects,\n        y\n      } = state;\n      const currentRenderedSide = getSide(renderedPlacement);\n      const currentRenderedAxis = getSideAxis(currentRenderedSide);\n      const arrowEl = arrowRef.current;\n      const arrowX = middlewareData.arrow?.x || 0;\n      const arrowY = middlewareData.arrow?.y || 0;\n      const arrowWidth = arrowEl?.clientWidth || 0;\n      const arrowHeight = arrowEl?.clientHeight || 0;\n      const transformX = arrowX + arrowWidth / 2;\n      const transformY = arrowY + arrowHeight / 2;\n      const shiftY = Math.abs(middlewareData.shift?.y || 0);\n      const halfAnchorHeight = rects.reference.height / 2;\n      const sideOffsetValue = typeof sideOffset === 'function' ? sideOffset(getOffsetData(state, sideParam, isRtl)) : sideOffset;\n      const isOverlappingAnchor = shiftY > sideOffsetValue;\n      const adjacentTransformOrigin = {\n        top: `${transformX}px calc(100% + ${sideOffsetValue}px)`,\n        bottom: `${transformX}px ${-sideOffsetValue}px`,\n        left: `calc(100% + ${sideOffsetValue}px) ${transformY}px`,\n        right: `${-sideOffsetValue}px ${transformY}px`\n      }[currentRenderedSide];\n      const overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y}px`;\n      elements.floating.style.setProperty('--transform-origin', crossAxisShiftEnabled && currentRenderedAxis === 'y' && isOverlappingAnchor ? overlapTransformOrigin : adjacentTransformOrigin);\n      return {};\n    }\n  }, adaptiveOrigin);\n\n  // Ensure positioning doesn't run initially for `keepMounted` elements that\n  // aren't initially open.\n  let rootContext = floatingRootContext;\n  if (!mounted && floatingRootContext) {\n    rootContext = {\n      ...floatingRootContext,\n      elements: {\n        reference: null,\n        floating: null,\n        domReference: null\n      }\n    };\n  }\n  const autoUpdateOptions = React.useMemo(() => ({\n    elementResize: trackAnchor && typeof ResizeObserver !== 'undefined',\n    layoutShift: trackAnchor && typeof IntersectionObserver !== 'undefined'\n  }), [trackAnchor]);\n  const {\n    refs,\n    elements,\n    x,\n    y,\n    middlewareData,\n    update,\n    placement: renderedPlacement,\n    context,\n    isPositioned,\n    floatingStyles: originalFloatingStyles\n  } = useFloating({\n    rootContext,\n    placement,\n    middleware,\n    strategy: positionMethod,\n    whileElementsMounted: keepMounted ? undefined : (...args) => autoUpdate(...args, autoUpdateOptions),\n    nodeId\n  });\n  const {\n    sideX,\n    sideY\n  } = middlewareData.adaptiveOrigin || {};\n  const floatingStyles = React.useMemo(() => adaptiveOrigin ? {\n    position: positionMethod,\n    [sideX]: `${x}px`,\n    [sideY]: `${y}px`\n  } : originalFloatingStyles, [adaptiveOrigin, sideX, sideY, positionMethod, x, y, originalFloatingStyles]);\n  const registeredPositionReferenceRef = React.useRef(null);\n  useIsoLayoutEffect(() => {\n    if (!mounted) {\n      return;\n    }\n    const anchorValue = anchorValueRef.current;\n    const resolvedAnchor = typeof anchorValue === 'function' ? anchorValue() : anchorValue;\n    const unwrappedElement = (isRef(resolvedAnchor) ? resolvedAnchor.current : resolvedAnchor) || null;\n    const finalAnchor = unwrappedElement || null;\n    if (finalAnchor !== registeredPositionReferenceRef.current) {\n      refs.setPositionReference(finalAnchor);\n      registeredPositionReferenceRef.current = finalAnchor;\n    }\n  }, [mounted, refs, anchorDep, anchorValueRef]);\n  React.useEffect(() => {\n    if (!mounted) {\n      return;\n    }\n    const anchorValue = anchorValueRef.current;\n\n    // Refs from parent components are set after useLayoutEffect runs and are available in useEffect.\n    // Therefore, if the anchor is a ref, we need to update the position reference in useEffect.\n    if (typeof anchorValue === 'function') {\n      return;\n    }\n    if (isRef(anchorValue) && anchorValue.current !== registeredPositionReferenceRef.current) {\n      refs.setPositionReference(anchorValue.current);\n      registeredPositionReferenceRef.current = anchorValue.current;\n    }\n  }, [mounted, refs, anchorDep, anchorValueRef]);\n  React.useEffect(() => {\n    if (keepMounted && mounted && elements.domReference && elements.floating) {\n      return autoUpdate(elements.domReference, elements.floating, update, autoUpdateOptions);\n    }\n    return undefined;\n  }, [keepMounted, mounted, elements, update, autoUpdateOptions]);\n  const renderedSide = getSide(renderedPlacement);\n  const logicalRenderedSide = getLogicalSide(sideParam, renderedSide, isRtl);\n  const renderedAlign = getAlignment(renderedPlacement) || 'center';\n  const anchorHidden = Boolean(middlewareData.hide?.referenceHidden);\n\n  /**\n   * Locks the flip (makes it \"sticky\") so it doesn't prefer a given placement\n   * and flips back lazily, not eagerly. Ideal for filtered lists that change\n   * the size of the popup dynamically to avoid unwanted flipping when typing.\n   */\n  useIsoLayoutEffect(() => {\n    if (lazyFlip && mounted && isPositioned) {\n      setMountSide(renderedSide);\n    }\n  }, [lazyFlip, mounted, isPositioned, renderedSide]);\n  const arrowStyles = React.useMemo(() => ({\n    position: 'absolute',\n    top: middlewareData.arrow?.y,\n    left: middlewareData.arrow?.x\n  }), [middlewareData.arrow]);\n  const arrowUncentered = middlewareData.arrow?.centerOffset !== 0;\n  return React.useMemo(() => ({\n    positionerStyles: floatingStyles,\n    arrowStyles,\n    arrowRef,\n    arrowUncentered,\n    side: logicalRenderedSide,\n    align: renderedAlign,\n    physicalSide: renderedSide,\n    anchorHidden,\n    refs,\n    context,\n    isPositioned,\n    update\n  }), [floatingStyles, arrowStyles, arrowRef, arrowUncentered, logicalRenderedSide, renderedAlign, renderedSide, anchorHidden, refs, context, isPositioned, update]);\n}\nfunction isRef(param) {\n  return param != null && 'current' in param;\n}","map":{"version":3,"names":["React","getSide","getAlignment","getSideAxis","ownerDocument","useIsoLayoutEffect","useLatestRef","useEventCallback","autoUpdate","flip","limitShift","offset","shift","useFloating","size","hide","useDirection","arrow","getLogicalSide","sideParam","renderedSide","isRtl","isLogicalSideParam","logicalRight","logicalLeft","top","right","bottom","left","getOffsetData","state","rects","placement","data","side","align","anchor","width","reference","height","positioner","floating","useAnchorPositioning","params","positionMethod","sideOffset","alignOffset","collisionBoundary","collisionPadding","collisionPaddingParam","sticky","arrowPadding","trackAnchor","keepMounted","floatingRootContext","mounted","collisionAvoidance","shiftCrossAxis","nodeId","adaptiveOrigin","lazyFlip","mountSide","setMountSide","useState","collisionAvoidanceSide","collisionAvoidanceAlign","collisionAvoidanceFallbackAxisSide","fallbackAxisSide","anchorFn","undefined","anchorFnCallback","anchorDep","anchorValueRef","direction","bias","biasTop","biasBottom","biasLeft","biasRight","commonCollisionProps","boundary","padding","arrowRef","useRef","sideOffsetRef","alignOffsetRef","sideOffsetDep","alignOffsetDep","middleware","sideAxis","current","alignAxis","mainAxis","crossAxis","alignmentAxis","shiftDisabled","crossAxisShiftEnabled","flipMiddleware","fallbackAxisSideDirection","shiftMiddleware","html","elements","documentElement","rootBoundary","x","y","clientWidth","clientHeight","limiter","limitData","getBoundingClientRect","arrowSize","offsetAmount","push","apply","availableWidth","availableHeight","Object","entries","forEach","key","value","style","setProperty","element","document","createElement","offsetParent","name","fn","middlewareData","renderedPlacement","currentRenderedSide","currentRenderedAxis","arrowEl","arrowX","arrowY","arrowWidth","arrowHeight","transformX","transformY","shiftY","Math","abs","halfAnchorHeight","sideOffsetValue","isOverlappingAnchor","adjacentTransformOrigin","overlapTransformOrigin","rootContext","domReference","autoUpdateOptions","useMemo","elementResize","ResizeObserver","layoutShift","IntersectionObserver","refs","update","context","isPositioned","floatingStyles","originalFloatingStyles","strategy","whileElementsMounted","args","sideX","sideY","position","registeredPositionReferenceRef","anchorValue","resolvedAnchor","unwrappedElement","isRef","finalAnchor","setPositionReference","useEffect","logicalRenderedSide","renderedAlign","anchorHidden","Boolean","referenceHidden","arrowStyles","arrowUncentered","centerOffset","positionerStyles","physicalSide","param"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/utils/useAnchorPositioning.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { getSide, getAlignment, getSideAxis } from '@floating-ui/utils';\nimport { ownerDocument } from '@base-ui-components/utils/owner';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useLatestRef } from '@base-ui-components/utils/useLatestRef';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { autoUpdate, flip, limitShift, offset, shift, useFloating, size, hide } from \"../floating-ui-react/index.js\";\nimport { useDirection } from \"../direction-provider/DirectionContext.js\";\nimport { arrow } from \"../floating-ui-react/middleware/arrow.js\";\nfunction getLogicalSide(sideParam, renderedSide, isRtl) {\n  const isLogicalSideParam = sideParam === 'inline-start' || sideParam === 'inline-end';\n  const logicalRight = isRtl ? 'inline-start' : 'inline-end';\n  const logicalLeft = isRtl ? 'inline-end' : 'inline-start';\n  return {\n    top: 'top',\n    right: isLogicalSideParam ? logicalRight : 'right',\n    bottom: 'bottom',\n    left: isLogicalSideParam ? logicalLeft : 'left'\n  }[renderedSide];\n}\nfunction getOffsetData(state, sideParam, isRtl) {\n  const {\n    rects,\n    placement\n  } = state;\n  const data = {\n    side: getLogicalSide(sideParam, getSide(placement), isRtl),\n    align: getAlignment(placement) || 'center',\n    anchor: {\n      width: rects.reference.width,\n      height: rects.reference.height\n    },\n    positioner: {\n      width: rects.floating.width,\n      height: rects.floating.height\n    }\n  };\n  return data;\n}\n/**\n * Provides standardized anchor positioning behavior for floating elements. Wraps Floating UI's\n * `useFloating` hook.\n */\nexport function useAnchorPositioning(params) {\n  const {\n    // Public parameters\n    anchor,\n    positionMethod = 'absolute',\n    side: sideParam = 'bottom',\n    sideOffset = 0,\n    align = 'center',\n    alignOffset = 0,\n    collisionBoundary,\n    collisionPadding: collisionPaddingParam = 5,\n    sticky = false,\n    arrowPadding = 5,\n    trackAnchor = true,\n    // Private parameters\n    keepMounted = false,\n    floatingRootContext,\n    mounted,\n    collisionAvoidance,\n    shiftCrossAxis = false,\n    nodeId,\n    adaptiveOrigin,\n    lazyFlip = false\n  } = params;\n  const [mountSide, setMountSide] = React.useState(null);\n  if (!mounted && mountSide !== null) {\n    setMountSide(null);\n  }\n  const collisionAvoidanceSide = collisionAvoidance.side || 'flip';\n  const collisionAvoidanceAlign = collisionAvoidance.align || 'flip';\n  const collisionAvoidanceFallbackAxisSide = collisionAvoidance.fallbackAxisSide || 'end';\n  const anchorFn = typeof anchor === 'function' ? anchor : undefined;\n  const anchorFnCallback = useEventCallback(anchorFn);\n  const anchorDep = anchorFn ? anchorFnCallback : anchor;\n  const anchorValueRef = useLatestRef(anchor);\n  const direction = useDirection();\n  const isRtl = direction === 'rtl';\n  const side = mountSide || {\n    top: 'top',\n    right: 'right',\n    bottom: 'bottom',\n    left: 'left',\n    'inline-end': isRtl ? 'left' : 'right',\n    'inline-start': isRtl ? 'right' : 'left'\n  }[sideParam];\n  const placement = align === 'center' ? side : `${side}-${align}`;\n  let collisionPadding = collisionPaddingParam;\n\n  // Create a bias to the preferred side.\n  // On iOS, when the mobile software keyboard opens, the input is exactly centered\n  // in the viewport, but this can cause it to flip to the top undesirably.\n  const bias = 1;\n  const biasTop = sideParam === 'bottom' ? bias : 0;\n  const biasBottom = sideParam === 'top' ? bias : 0;\n  const biasLeft = sideParam === 'right' ? bias : 0;\n  const biasRight = sideParam === 'left' ? bias : 0;\n  if (typeof collisionPadding === 'number') {\n    collisionPadding = {\n      top: collisionPadding + biasTop,\n      right: collisionPadding + biasRight,\n      bottom: collisionPadding + biasBottom,\n      left: collisionPadding + biasLeft\n    };\n  } else if (collisionPadding) {\n    collisionPadding = {\n      top: (collisionPadding.top || 0) + biasTop,\n      right: (collisionPadding.right || 0) + biasRight,\n      bottom: (collisionPadding.bottom || 0) + biasBottom,\n      left: (collisionPadding.left || 0) + biasLeft\n    };\n  }\n  const commonCollisionProps = {\n    boundary: collisionBoundary === 'clipping-ancestors' ? 'clippingAncestors' : collisionBoundary,\n    padding: collisionPadding\n  };\n\n  // Using a ref assumes that the arrow element is always present in the DOM for the lifetime of the\n  // popup. If this assumption ends up being false, we can switch to state to manage the arrow's\n  // presence.\n  const arrowRef = React.useRef(null);\n\n  // Keep these reactive if they're not functions\n  const sideOffsetRef = useLatestRef(sideOffset);\n  const alignOffsetRef = useLatestRef(alignOffset);\n  const sideOffsetDep = typeof sideOffset !== 'function' ? sideOffset : 0;\n  const alignOffsetDep = typeof alignOffset !== 'function' ? alignOffset : 0;\n  const middleware = [offset(state => {\n    const data = getOffsetData(state, sideParam, isRtl);\n    const sideAxis = typeof sideOffsetRef.current === 'function' ? sideOffsetRef.current(data) : sideOffsetRef.current;\n    const alignAxis = typeof alignOffsetRef.current === 'function' ? alignOffsetRef.current(data) : alignOffsetRef.current;\n    return {\n      mainAxis: sideAxis,\n      crossAxis: alignAxis,\n      alignmentAxis: alignAxis\n    };\n  }, [sideOffsetDep, alignOffsetDep, isRtl, sideParam])];\n  const shiftDisabled = collisionAvoidanceAlign === 'none' && collisionAvoidanceSide !== 'shift';\n  const crossAxisShiftEnabled = !shiftDisabled && (sticky || shiftCrossAxis || collisionAvoidanceSide === 'shift');\n  const flipMiddleware = collisionAvoidanceSide === 'none' ? null : flip({\n    ...commonCollisionProps,\n    // Ensure the popup flips if it's been limited by its --available-height and it resizes.\n    // Since the size() padding is smaller than the flip() padding, flip() will take precedence.\n    padding: {\n      top: collisionPadding.top + bias,\n      right: collisionPadding.right + bias,\n      bottom: collisionPadding.bottom + bias,\n      left: collisionPadding.left + bias\n    },\n    mainAxis: !shiftCrossAxis && collisionAvoidanceSide === 'flip',\n    crossAxis: collisionAvoidanceAlign === 'flip' ? 'alignment' : false,\n    fallbackAxisSideDirection: collisionAvoidanceFallbackAxisSide\n  });\n  const shiftMiddleware = shiftDisabled ? null : shift(data => {\n    const html = ownerDocument(data.elements.floating).documentElement;\n    return {\n      ...commonCollisionProps,\n      // Use the Layout Viewport to avoid shifting around when pinch-zooming\n      // for context menus.\n      rootBoundary: shiftCrossAxis ? {\n        x: 0,\n        y: 0,\n        width: html.clientWidth,\n        height: html.clientHeight\n      } : undefined,\n      mainAxis: collisionAvoidanceAlign !== 'none',\n      crossAxis: crossAxisShiftEnabled,\n      limiter: sticky || shiftCrossAxis ? undefined : limitShift(limitData => {\n        if (!arrowRef.current) {\n          return {};\n        }\n        const {\n          width,\n          height\n        } = arrowRef.current.getBoundingClientRect();\n        const sideAxis = getSideAxis(getSide(limitData.placement));\n        const arrowSize = sideAxis === 'y' ? width : height;\n        const offsetAmount = sideAxis === 'y' ? collisionPadding.left + collisionPadding.right : collisionPadding.top + collisionPadding.bottom;\n        return {\n          offset: arrowSize / 2 + offsetAmount / 2\n        };\n      })\n    };\n  }, [commonCollisionProps, sticky, shiftCrossAxis, collisionPadding, collisionAvoidanceAlign]);\n\n  // https://floating-ui.com/docs/flip#combining-with-shift\n  if (collisionAvoidanceSide === 'shift' || collisionAvoidanceAlign === 'shift' || align === 'center') {\n    middleware.push(shiftMiddleware, flipMiddleware);\n  } else {\n    middleware.push(flipMiddleware, shiftMiddleware);\n  }\n  middleware.push(size({\n    ...commonCollisionProps,\n    apply({\n      elements: {\n        floating\n      },\n      rects: {\n        reference\n      },\n      availableWidth,\n      availableHeight\n    }) {\n      Object.entries({\n        '--available-width': `${availableWidth}px`,\n        '--available-height': `${availableHeight}px`,\n        '--anchor-width': `${reference.width}px`,\n        '--anchor-height': `${reference.height}px`\n      }).forEach(([key, value]) => {\n        floating.style.setProperty(key, value);\n      });\n    }\n  }), arrow(() => ({\n    // `transform-origin` calculations rely on an element existing. If the arrow hasn't been set,\n    // we'll create a fake element.\n    element: arrowRef.current || document.createElement('div'),\n    padding: arrowPadding,\n    offsetParent: 'floating'\n  }), [arrowPadding]), hide(), {\n    name: 'transformOrigin',\n    fn(state) {\n      const {\n        elements,\n        middlewareData,\n        placement: renderedPlacement,\n        rects,\n        y\n      } = state;\n      const currentRenderedSide = getSide(renderedPlacement);\n      const currentRenderedAxis = getSideAxis(currentRenderedSide);\n      const arrowEl = arrowRef.current;\n      const arrowX = middlewareData.arrow?.x || 0;\n      const arrowY = middlewareData.arrow?.y || 0;\n      const arrowWidth = arrowEl?.clientWidth || 0;\n      const arrowHeight = arrowEl?.clientHeight || 0;\n      const transformX = arrowX + arrowWidth / 2;\n      const transformY = arrowY + arrowHeight / 2;\n      const shiftY = Math.abs(middlewareData.shift?.y || 0);\n      const halfAnchorHeight = rects.reference.height / 2;\n      const sideOffsetValue = typeof sideOffset === 'function' ? sideOffset(getOffsetData(state, sideParam, isRtl)) : sideOffset;\n      const isOverlappingAnchor = shiftY > sideOffsetValue;\n      const adjacentTransformOrigin = {\n        top: `${transformX}px calc(100% + ${sideOffsetValue}px)`,\n        bottom: `${transformX}px ${-sideOffsetValue}px`,\n        left: `calc(100% + ${sideOffsetValue}px) ${transformY}px`,\n        right: `${-sideOffsetValue}px ${transformY}px`\n      }[currentRenderedSide];\n      const overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y}px`;\n      elements.floating.style.setProperty('--transform-origin', crossAxisShiftEnabled && currentRenderedAxis === 'y' && isOverlappingAnchor ? overlapTransformOrigin : adjacentTransformOrigin);\n      return {};\n    }\n  }, adaptiveOrigin);\n\n  // Ensure positioning doesn't run initially for `keepMounted` elements that\n  // aren't initially open.\n  let rootContext = floatingRootContext;\n  if (!mounted && floatingRootContext) {\n    rootContext = {\n      ...floatingRootContext,\n      elements: {\n        reference: null,\n        floating: null,\n        domReference: null\n      }\n    };\n  }\n  const autoUpdateOptions = React.useMemo(() => ({\n    elementResize: trackAnchor && typeof ResizeObserver !== 'undefined',\n    layoutShift: trackAnchor && typeof IntersectionObserver !== 'undefined'\n  }), [trackAnchor]);\n  const {\n    refs,\n    elements,\n    x,\n    y,\n    middlewareData,\n    update,\n    placement: renderedPlacement,\n    context,\n    isPositioned,\n    floatingStyles: originalFloatingStyles\n  } = useFloating({\n    rootContext,\n    placement,\n    middleware,\n    strategy: positionMethod,\n    whileElementsMounted: keepMounted ? undefined : (...args) => autoUpdate(...args, autoUpdateOptions),\n    nodeId\n  });\n  const {\n    sideX,\n    sideY\n  } = middlewareData.adaptiveOrigin || {};\n  const floatingStyles = React.useMemo(() => adaptiveOrigin ? {\n    position: positionMethod,\n    [sideX]: `${x}px`,\n    [sideY]: `${y}px`\n  } : originalFloatingStyles, [adaptiveOrigin, sideX, sideY, positionMethod, x, y, originalFloatingStyles]);\n  const registeredPositionReferenceRef = React.useRef(null);\n  useIsoLayoutEffect(() => {\n    if (!mounted) {\n      return;\n    }\n    const anchorValue = anchorValueRef.current;\n    const resolvedAnchor = typeof anchorValue === 'function' ? anchorValue() : anchorValue;\n    const unwrappedElement = (isRef(resolvedAnchor) ? resolvedAnchor.current : resolvedAnchor) || null;\n    const finalAnchor = unwrappedElement || null;\n    if (finalAnchor !== registeredPositionReferenceRef.current) {\n      refs.setPositionReference(finalAnchor);\n      registeredPositionReferenceRef.current = finalAnchor;\n    }\n  }, [mounted, refs, anchorDep, anchorValueRef]);\n  React.useEffect(() => {\n    if (!mounted) {\n      return;\n    }\n    const anchorValue = anchorValueRef.current;\n\n    // Refs from parent components are set after useLayoutEffect runs and are available in useEffect.\n    // Therefore, if the anchor is a ref, we need to update the position reference in useEffect.\n    if (typeof anchorValue === 'function') {\n      return;\n    }\n    if (isRef(anchorValue) && anchorValue.current !== registeredPositionReferenceRef.current) {\n      refs.setPositionReference(anchorValue.current);\n      registeredPositionReferenceRef.current = anchorValue.current;\n    }\n  }, [mounted, refs, anchorDep, anchorValueRef]);\n  React.useEffect(() => {\n    if (keepMounted && mounted && elements.domReference && elements.floating) {\n      return autoUpdate(elements.domReference, elements.floating, update, autoUpdateOptions);\n    }\n    return undefined;\n  }, [keepMounted, mounted, elements, update, autoUpdateOptions]);\n  const renderedSide = getSide(renderedPlacement);\n  const logicalRenderedSide = getLogicalSide(sideParam, renderedSide, isRtl);\n  const renderedAlign = getAlignment(renderedPlacement) || 'center';\n  const anchorHidden = Boolean(middlewareData.hide?.referenceHidden);\n\n  /**\n   * Locks the flip (makes it \"sticky\") so it doesn't prefer a given placement\n   * and flips back lazily, not eagerly. Ideal for filtered lists that change\n   * the size of the popup dynamically to avoid unwanted flipping when typing.\n   */\n  useIsoLayoutEffect(() => {\n    if (lazyFlip && mounted && isPositioned) {\n      setMountSide(renderedSide);\n    }\n  }, [lazyFlip, mounted, isPositioned, renderedSide]);\n  const arrowStyles = React.useMemo(() => ({\n    position: 'absolute',\n    top: middlewareData.arrow?.y,\n    left: middlewareData.arrow?.x\n  }), [middlewareData.arrow]);\n  const arrowUncentered = middlewareData.arrow?.centerOffset !== 0;\n  return React.useMemo(() => ({\n    positionerStyles: floatingStyles,\n    arrowStyles,\n    arrowRef,\n    arrowUncentered,\n    side: logicalRenderedSide,\n    align: renderedAlign,\n    physicalSide: renderedSide,\n    anchorHidden,\n    refs,\n    context,\n    isPositioned,\n    update\n  }), [floatingStyles, arrowStyles, arrowRef, arrowUncentered, logicalRenderedSide, renderedAlign, renderedSide, anchorHidden, refs, context, isPositioned, update]);\n}\nfunction isRef(param) {\n  return param != null && 'current' in param;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}