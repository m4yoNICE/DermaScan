{"ast":null,"code":"import { isHTMLElement, isShadowRoot } from '@floating-ui/utils/dom';\nimport { isJSDOM } from '@base-ui-components/utils/detectBrowser';\nimport { FOCUSABLE_ATTRIBUTE, TYPEABLE_SELECTOR } from \"./constants.js\";\nexport function activeElement(doc) {\n  let element = doc.activeElement;\n  while (element?.shadowRoot?.activeElement != null) {\n    element = element.shadowRoot.activeElement;\n  }\n  return element;\n}\nexport function contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode?.();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\nexport function getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nexport function isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const eventAgain = event;\n  return eventAgain.target != null && node.contains(eventAgain.target);\n}\nexport function isRootElement(element) {\n  return element.matches('html,body');\n}\nexport function getDocument(node) {\n  return node?.ownerDocument || document;\n}\nexport function isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nexport function isTypeableCombobox(element) {\n  if (!element) {\n    return false;\n  }\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\nexport function matchesFocusVisible(element) {\n  // We don't want to block focus from working with `visibleOnly`\n  // (JSDOM doesn't match `:focus-visible` when the element has `:focus`)\n  if (!element || isJSDOM) {\n    return true;\n  }\n  try {\n    return element.matches(':focus-visible');\n  } catch (_e) {\n    return true;\n  }\n}\nexport function getFloatingFocusElement(floatingElement) {\n  if (!floatingElement) {\n    return null;\n  }\n  // Try to find the element that has `{...getFloatingProps()}` spread on it.\n  // This indicates the floating element is acting as a positioning wrapper, and\n  // so focus should be managed on the child element with the event handlers and\n  // aria props.\n  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(`[${FOCUSABLE_ATTRIBUTE}]`) || floatingElement;\n}","map":{"version":3,"names":["isHTMLElement","isShadowRoot","isJSDOM","FOCUSABLE_ATTRIBUTE","TYPEABLE_SELECTOR","activeElement","doc","element","shadowRoot","contains","parent","child","rootNode","getRootNode","next","parentNode","host","getTarget","event","composedPath","target","isEventTargetWithin","node","includes","eventAgain","isRootElement","matches","getDocument","ownerDocument","document","isTypeableElement","isTypeableCombobox","getAttribute","matchesFocusVisible","_e","getFloatingFocusElement","floatingElement","hasAttribute","querySelector"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/floating-ui-react/utils/element.js"],"sourcesContent":["import { isHTMLElement, isShadowRoot } from '@floating-ui/utils/dom';\nimport { isJSDOM } from '@base-ui-components/utils/detectBrowser';\nimport { FOCUSABLE_ATTRIBUTE, TYPEABLE_SELECTOR } from \"./constants.js\";\nexport function activeElement(doc) {\n  let element = doc.activeElement;\n  while (element?.shadowRoot?.activeElement != null) {\n    element = element.shadowRoot.activeElement;\n  }\n  return element;\n}\nexport function contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode?.();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\nexport function getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nexport function isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const eventAgain = event;\n  return eventAgain.target != null && node.contains(eventAgain.target);\n}\nexport function isRootElement(element) {\n  return element.matches('html,body');\n}\nexport function getDocument(node) {\n  return node?.ownerDocument || document;\n}\nexport function isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nexport function isTypeableCombobox(element) {\n  if (!element) {\n    return false;\n  }\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\nexport function matchesFocusVisible(element) {\n  // We don't want to block focus from working with `visibleOnly`\n  // (JSDOM doesn't match `:focus-visible` when the element has `:focus`)\n  if (!element || isJSDOM) {\n    return true;\n  }\n  try {\n    return element.matches(':focus-visible');\n  } catch (_e) {\n    return true;\n  }\n}\nexport function getFloatingFocusElement(floatingElement) {\n  if (!floatingElement) {\n    return null;\n  }\n  // Try to find the element that has `{...getFloatingProps()}` spread on it.\n  // This indicates the floating element is acting as a positioning wrapper, and\n  // so focus should be managed on the child element with the event handlers and\n  // aria props.\n  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(`[${FOCUSABLE_ATTRIBUTE}]`) || floatingElement;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}