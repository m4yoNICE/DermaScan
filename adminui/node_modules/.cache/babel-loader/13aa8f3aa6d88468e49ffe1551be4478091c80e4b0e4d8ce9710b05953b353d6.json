{"ast":null,"code":"import * as React from 'react';\nimport { useFloating as usePosition } from '@floating-ui/react-dom';\nimport { isElement } from '@floating-ui/utils/dom';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useFloatingTree } from \"../components/FloatingTree.js\";\nimport { useFloatingRootContext } from \"./useFloatingRootContext.js\";\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nexport function useFloating(options = {}) {\n  const {\n    nodeId\n  } = options;\n  const internalRootContext = useFloatingRootContext({\n    ...options,\n    elements: {\n      reference: null,\n      floating: null,\n      ...options.elements\n    }\n  });\n  const rootContext = options.rootContext || internalRootContext;\n  const computedElements = rootContext.elements;\n  const [domReferenceState, setDomReference] = React.useState(null);\n  const [positionReference, setPositionReferenceRaw] = React.useState(null);\n  const optionDomReference = computedElements?.domReference;\n  const domReference = optionDomReference || domReferenceState;\n  const domReferenceRef = React.useRef(null);\n  const tree = useFloatingTree();\n  useIsoLayoutEffect(() => {\n    if (domReference) {\n      domReferenceRef.current = domReference;\n    }\n  }, [domReference]);\n  const position = usePosition({\n    ...options,\n    elements: {\n      ...computedElements,\n      ...(positionReference && {\n        reference: positionReference\n      })\n    }\n  });\n  const setPositionReference = React.useCallback(node => {\n    const computedPositionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      getClientRects: () => node.getClientRects(),\n      contextElement: node\n    } : node;\n    // Store the positionReference in state if the DOM reference is specified externally via the\n    // `elements.reference` option. This ensures that it won't be overridden on future renders.\n    setPositionReferenceRaw(computedPositionReference);\n    position.refs.setReference(computedPositionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference\n  }), [position.elements, domReference]);\n  const context = React.useMemo(() => ({\n    ...position,\n    ...rootContext,\n    refs,\n    elements,\n    nodeId\n  }), [position, refs, elements, nodeId, rootContext]);\n  useIsoLayoutEffect(() => {\n    rootContext.dataRef.current.floatingContext = context;\n    const node = tree?.nodesRef.current.find(n => n.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}","map":{"version":3,"names":["React","useFloating","usePosition","isElement","useIsoLayoutEffect","useFloatingTree","useFloatingRootContext","options","nodeId","internalRootContext","elements","reference","floating","rootContext","computedElements","domReferenceState","setDomReference","useState","positionReference","setPositionReferenceRaw","optionDomReference","domReference","domReferenceRef","useRef","tree","current","position","setPositionReference","useCallback","node","computedPositionReference","getBoundingClientRect","getClientRects","contextElement","refs","setReference","useMemo","context","dataRef","floatingContext","nodesRef","find","n","id"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/floating-ui-react/hooks/useFloating.js"],"sourcesContent":["import * as React from 'react';\nimport { useFloating as usePosition } from '@floating-ui/react-dom';\nimport { isElement } from '@floating-ui/utils/dom';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useFloatingTree } from \"../components/FloatingTree.js\";\nimport { useFloatingRootContext } from \"./useFloatingRootContext.js\";\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nexport function useFloating(options = {}) {\n  const {\n    nodeId\n  } = options;\n  const internalRootContext = useFloatingRootContext({\n    ...options,\n    elements: {\n      reference: null,\n      floating: null,\n      ...options.elements\n    }\n  });\n  const rootContext = options.rootContext || internalRootContext;\n  const computedElements = rootContext.elements;\n  const [domReferenceState, setDomReference] = React.useState(null);\n  const [positionReference, setPositionReferenceRaw] = React.useState(null);\n  const optionDomReference = computedElements?.domReference;\n  const domReference = optionDomReference || domReferenceState;\n  const domReferenceRef = React.useRef(null);\n  const tree = useFloatingTree();\n  useIsoLayoutEffect(() => {\n    if (domReference) {\n      domReferenceRef.current = domReference;\n    }\n  }, [domReference]);\n  const position = usePosition({\n    ...options,\n    elements: {\n      ...computedElements,\n      ...(positionReference && {\n        reference: positionReference\n      })\n    }\n  });\n  const setPositionReference = React.useCallback(node => {\n    const computedPositionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      getClientRects: () => node.getClientRects(),\n      contextElement: node\n    } : node;\n    // Store the positionReference in state if the DOM reference is specified externally via the\n    // `elements.reference` option. This ensures that it won't be overridden on future renders.\n    setPositionReferenceRaw(computedPositionReference);\n    position.refs.setReference(computedPositionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference\n  }), [position.elements, domReference]);\n  const context = React.useMemo(() => ({\n    ...position,\n    ...rootContext,\n    refs,\n    elements,\n    nodeId\n  }), [position, refs, elements, nodeId, rootContext]);\n  useIsoLayoutEffect(() => {\n    rootContext.dataRef.current.floatingContext = context;\n    const node = tree?.nodesRef.current.find(n => n.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}