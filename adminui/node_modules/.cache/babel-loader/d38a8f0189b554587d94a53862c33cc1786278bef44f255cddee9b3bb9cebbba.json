{"ast":null,"code":"import * as React from 'react';\nimport { getOverflowAncestors } from '@floating-ui/react-dom';\nimport { getComputedStyle, getParentNode, isElement, isHTMLElement, isLastTraversableNode, isWebKit } from '@floating-ui/utils/dom';\nimport { Timeout, useTimeout } from '@base-ui-components/utils/useTimeout';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { contains, getDocument, getTarget, isEventTargetWithin, isReactEvent, isRootElement, getNodeChildren } from \"../utils.js\";\n\n/* eslint-disable no-underscore-dangle */\n\nimport { useFloatingTree } from \"../components/FloatingTree.js\";\nimport { createChangeEventDetails } from \"../../utils/createBaseUIEventDetails.js\";\nimport { createAttribute } from \"../utils/createAttribute.js\";\nconst bubbleHandlerKeys = {\n  intentional: 'onClick',\n  sloppy: 'onPointerDown'\n};\nexport function normalizeProp(normalizable) {\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : normalizable?.escapeKey ?? false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : normalizable?.outsidePress ?? true\n  };\n}\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nexport function useDismiss(context, props = {}) {\n  const {\n    open,\n    onOpenChange,\n    elements,\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: outsidePressProp = true,\n    outsidePressEvent = 'sloppy',\n    referencePress = false,\n    referencePressEvent = 'sloppy',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEventCallback(typeof outsidePressProp === 'function' ? outsidePressProp : () => false);\n  const outsidePress = typeof outsidePressProp === 'function' ? outsidePressFn : outsidePressProp;\n  const endedOrStartedInsideRef = React.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const touchStateRef = React.useRef(null);\n  const cancelDismissOnEndTimeout = useTimeout();\n  const insideReactTreeTimeout = useTimeout();\n  const isComposingRef = React.useRef(false);\n  const currentPointerTypeRef = React.useRef('');\n  const trackPointerType = useEventCallback(event => {\n    currentPointerTypeRef.current = event.pointerType;\n  });\n  const getOutsidePressEvent = useEventCallback(() => {\n    const type = currentPointerTypeRef.current;\n    const computedType = type === 'pen' || !type ? 'mouse' : type;\n    const resolved = typeof outsidePressEvent === 'function' ? outsidePressEvent() : outsidePressEvent;\n    if (typeof resolved === 'string') {\n      return resolved;\n    }\n    return resolved[computedType];\n  });\n  const closeOnEscapeKeyDown = useEventCallback(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n\n    // Wait until IME is settled. Pressing `Escape` while composing should\n    // close the compose menu, but not the floating element.\n    if (isComposingRef.current) {\n      return;\n    }\n    const nodeId = dataRef.current.floatingContext?.nodeId;\n    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          if (child.context?.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    const native = isReactEvent(event) ? event.nativeEvent : event;\n    const eventDetails = createChangeEventDetails('escape-key', native);\n    onOpenChange(false, eventDetails);\n    if (!escapeKeyBubbles && !eventDetails.isPropagationAllowed) {\n      event.stopPropagation();\n    }\n  });\n  const shouldIgnoreEvent = useEventCallback(event => {\n    const computedOutsidePressEvent = getOutsidePressEvent();\n    return computedOutsidePressEvent === 'intentional' && event.type !== 'click' || computedOutsidePressEvent === 'sloppy' && event.type === 'click';\n  });\n  const closeOnEscapeKeyDownCapture = useEventCallback(event => {\n    const callback = () => {\n      closeOnEscapeKeyDown(event);\n      getTarget(event)?.removeEventListener('keydown', callback);\n    };\n    getTarget(event)?.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEventCallback((event, endedOrStartedInside = false) => {\n    if (shouldIgnoreEvent(event)) {\n      return;\n    }\n\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = dataRef.current.insideReactTree;\n    dataRef.current.insideReactTree = false;\n    if (getOutsidePressEvent() === 'intentional' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n    const inertSelector = `[${createAttribute('inert')}]`;\n    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = isElement(target) ? target : null;\n    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {\n      const nextParent = getParentNode(targetRootAncestor);\n      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && isElement(target) && !isRootElement(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !contains(target, elements.floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !contains(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target)) {\n      const lastTraversableNode = isLastTraversableNode(target);\n      const style = getComputedStyle(target);\n      const scrollRe = /auto|scroll/;\n      const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);\n      const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);\n      const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      const isRTL = style.direction === 'rtl';\n\n      // Check click position relative to scrollbar.\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      const pressedVerticalScrollbar = canScrollY && (isRTL ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);\n      const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;\n      if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {\n        return;\n      }\n    }\n    const nodeId = dataRef.current.floatingContext?.nodeId;\n    const targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some(node => isEventTargetWithin(event, node.context?.elements.floating));\n    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        if (child.context?.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, createChangeEventDetails('outside-press', event));\n  });\n  const handlePointerDown = useEventCallback(event => {\n    if (getOutsidePressEvent() !== 'sloppy' || !open || !enabled || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference)) {\n      return;\n    }\n    if (event.pointerType === 'touch') {\n      touchStateRef.current = {\n        startTime: Date.now(),\n        startX: event.clientX,\n        startY: event.clientY,\n        dismissOnPointerUp: false,\n        dismissOnMouseDown: true\n      };\n      cancelDismissOnEndTimeout.start(1000, () => {\n        if (touchStateRef.current) {\n          touchStateRef.current.dismissOnPointerUp = false;\n          touchStateRef.current.dismissOnMouseDown = false;\n        }\n      });\n      return;\n    }\n    closeOnPressOutside(event);\n  });\n  const closeOnPressOutsideCapture = useEventCallback(event => {\n    // When click outside is lazy (`up` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (shouldIgnoreEvent(event)) {\n      return;\n    }\n    cancelDismissOnEndTimeout.clear();\n    if (event.type === 'mousedown' && touchStateRef.current && !touchStateRef.current.dismissOnMouseDown) {\n      return;\n    }\n    const callback = () => {\n      if (event.type === 'pointerdown') {\n        handlePointerDown(event);\n      } else {\n        closeOnPressOutside(event, endedOrStartedInside);\n      }\n      getTarget(event)?.removeEventListener(event.type, callback);\n    };\n    getTarget(event)?.addEventListener(event.type, callback);\n  });\n  const handlePointerMove = useEventCallback(event => {\n    if (getOutsidePressEvent() !== 'sloppy' || event.pointerType !== 'touch' || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference)) {\n      return;\n    }\n    const deltaX = Math.abs(event.clientX - touchStateRef.current.startX);\n    const deltaY = Math.abs(event.clientY - touchStateRef.current.startY);\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    if (distance > 5) {\n      touchStateRef.current.dismissOnPointerUp = true;\n    }\n    if (distance > 10) {\n      closeOnPressOutside(event);\n      cancelDismissOnEndTimeout.clear();\n      touchStateRef.current = null;\n    }\n  });\n  const handlePointerUp = useEventCallback(event => {\n    if (getOutsidePressEvent() !== 'sloppy' || event.pointerType !== 'touch' || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference)) {\n      return;\n    }\n    if (touchStateRef.current.dismissOnPointerUp) {\n      closeOnPressOutside(event);\n    }\n    cancelDismissOnEndTimeout.clear();\n    touchStateRef.current = null;\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return undefined;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    const compositionTimeout = new Timeout();\n    function onScroll(event) {\n      onOpenChange(false, createChangeEventDetails('none', event));\n    }\n    function handleCompositionStart() {\n      compositionTimeout.clear();\n      isComposingRef.current = true;\n    }\n    function handleCompositionEnd() {\n      // Safari fires `compositionend` before `keydown`, so we need to wait\n      // until the next tick to set `isComposing` to `false`.\n      // https://bugs.webkit.org/show_bug.cgi?id=165004\n      compositionTimeout.start(\n      // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.\n      // Only apply to WebKit for the test to remain 0ms.\n      isWebKit() ? 5 : 0, () => {\n        isComposingRef.current = false;\n      });\n    }\n    const doc = getDocument(elements.floating);\n    doc.addEventListener('pointerdown', trackPointerType, true);\n    if (escapeKey) {\n      doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      doc.addEventListener('compositionstart', handleCompositionStart);\n      doc.addEventListener('compositionend', handleCompositionEnd);\n    }\n    if (outsidePress) {\n      doc.addEventListener('click', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      doc.addEventListener('pointerdown', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      doc.addEventListener('pointermove', handlePointerMove, outsidePressCapture);\n      doc.addEventListener('pointerup', handlePointerUp, outsidePressCapture);\n      doc.addEventListener('mousedown', closeOnPressOutsideCapture, outsidePressCapture);\n    }\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(elements.domReference)) {\n        ancestors = getOverflowAncestors(elements.domReference);\n      }\n      if (isElement(elements.floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));\n      }\n      if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => ancestor !== doc.defaultView?.visualViewport);\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      doc.removeEventListener('pointerdown', trackPointerType, true);\n      if (escapeKey) {\n        doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        doc.removeEventListener('compositionstart', handleCompositionStart);\n        doc.removeEventListener('compositionend', handleCompositionEnd);\n      }\n      if (outsidePress) {\n        doc.removeEventListener('click', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        doc.removeEventListener('pointerdown', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        doc.removeEventListener('pointermove', handlePointerMove, outsidePressCapture);\n        doc.removeEventListener('pointerup', handlePointerUp, outsidePressCapture);\n        doc.removeEventListener('mousedown', closeOnPressOutsideCapture, outsidePressCapture);\n      }\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n      compositionTimeout.clear();\n    };\n  }, [dataRef, elements, escapeKey, outsidePress, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture, handlePointerDown, handlePointerMove, handlePointerUp, trackPointerType]);\n  React.useEffect(() => {\n    dataRef.current.insideReactTree = false;\n  }, [dataRef, outsidePress]);\n  const reference = React.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    ...(referencePress && {\n      [bubbleHandlerKeys[referencePressEvent]]: event => {\n        onOpenChange(false, createChangeEventDetails('trigger-press', event.nativeEvent));\n      },\n      ...(referencePressEvent !== 'intentional' && {\n        onClick(event) {\n          onOpenChange(false, createChangeEventDetails('trigger-press', event.nativeEvent));\n        }\n      })\n    })\n  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);\n  const handlePressedInside = useEventCallback(event => {\n    const target = getTarget(event.nativeEvent);\n    if (!contains(elements.floating, target) || event.button !== 0) {\n      return;\n    }\n    endedOrStartedInsideRef.current = true;\n  });\n  const handleCaptureInside = useEventCallback(() => {\n    dataRef.current.insideReactTree = true;\n    insideReactTreeTimeout.start(0, () => {\n      dataRef.current.insideReactTree = false;\n    });\n  });\n  const floating = React.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    onMouseDown: handlePressedInside,\n    onMouseUp: handlePressedInside,\n    onPointerDownCapture: handleCaptureInside,\n    onMouseDownCapture: handleCaptureInside,\n    onClickCapture: handleCaptureInside,\n    onMouseUpCapture: handleCaptureInside\n  }), [closeOnEscapeKeyDown, handlePressedInside, handleCaptureInside]);\n  return React.useMemo(() => enabled ? {\n    reference,\n    floating\n  } : {}, [enabled, reference, floating]);\n}","map":{"version":3,"names":["React","getOverflowAncestors","getComputedStyle","getParentNode","isElement","isHTMLElement","isLastTraversableNode","isWebKit","Timeout","useTimeout","useEventCallback","contains","getDocument","getTarget","isEventTargetWithin","isReactEvent","isRootElement","getNodeChildren","useFloatingTree","createChangeEventDetails","createAttribute","bubbleHandlerKeys","intentional","sloppy","normalizeProp","normalizable","escapeKey","outsidePress","useDismiss","context","props","open","onOpenChange","elements","dataRef","enabled","outsidePressProp","outsidePressEvent","referencePress","referencePressEvent","ancestorScroll","bubbles","capture","tree","outsidePressFn","endedOrStartedInsideRef","useRef","escapeKeyBubbles","outsidePressBubbles","escapeKeyCapture","outsidePressCapture","touchStateRef","cancelDismissOnEndTimeout","insideReactTreeTimeout","isComposingRef","currentPointerTypeRef","trackPointerType","event","current","pointerType","getOutsidePressEvent","type","computedType","resolved","closeOnEscapeKeyDown","key","nodeId","floatingContext","children","nodesRef","length","shouldDismiss","forEach","child","__escapeKeyBubbles","native","nativeEvent","eventDetails","isPropagationAllowed","stopPropagation","shouldIgnoreEvent","computedOutsidePressEvent","closeOnEscapeKeyDownCapture","callback","removeEventListener","addEventListener","closeOnPressOutside","endedOrStartedInside","insideReactTree","target","inertSelector","markers","floating","querySelectorAll","targetRootAncestor","nextParent","Array","from","every","marker","lastTraversableNode","style","scrollRe","isScrollableX","test","overflowX","isScrollableY","overflowY","canScrollX","clientWidth","scrollWidth","canScrollY","clientHeight","scrollHeight","isRTL","direction","pressedVerticalScrollbar","offsetX","offsetWidth","pressedHorizontalScrollbar","offsetY","targetIsInsideChildren","some","node","domReference","__outsidePressBubbles","handlePointerDown","startTime","Date","now","startX","clientX","startY","clientY","dismissOnPointerUp","dismissOnMouseDown","start","closeOnPressOutsideCapture","clear","handlePointerMove","deltaX","Math","abs","deltaY","distance","sqrt","handlePointerUp","useEffect","undefined","compositionTimeout","onScroll","handleCompositionStart","handleCompositionEnd","doc","ancestors","concat","reference","contextElement","filter","ancestor","defaultView","visualViewport","passive","useMemo","onKeyDown","onClick","handlePressedInside","button","handleCaptureInside","onMouseDown","onMouseUp","onPointerDownCapture","onMouseDownCapture","onClickCapture","onMouseUpCapture"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/floating-ui-react/hooks/useDismiss.js"],"sourcesContent":["import * as React from 'react';\nimport { getOverflowAncestors } from '@floating-ui/react-dom';\nimport { getComputedStyle, getParentNode, isElement, isHTMLElement, isLastTraversableNode, isWebKit } from '@floating-ui/utils/dom';\nimport { Timeout, useTimeout } from '@base-ui-components/utils/useTimeout';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { contains, getDocument, getTarget, isEventTargetWithin, isReactEvent, isRootElement, getNodeChildren } from \"../utils.js\";\n\n/* eslint-disable no-underscore-dangle */\n\nimport { useFloatingTree } from \"../components/FloatingTree.js\";\nimport { createChangeEventDetails } from \"../../utils/createBaseUIEventDetails.js\";\nimport { createAttribute } from \"../utils/createAttribute.js\";\nconst bubbleHandlerKeys = {\n  intentional: 'onClick',\n  sloppy: 'onPointerDown'\n};\nexport function normalizeProp(normalizable) {\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : normalizable?.escapeKey ?? false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : normalizable?.outsidePress ?? true\n  };\n}\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nexport function useDismiss(context, props = {}) {\n  const {\n    open,\n    onOpenChange,\n    elements,\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: outsidePressProp = true,\n    outsidePressEvent = 'sloppy',\n    referencePress = false,\n    referencePressEvent = 'sloppy',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEventCallback(typeof outsidePressProp === 'function' ? outsidePressProp : () => false);\n  const outsidePress = typeof outsidePressProp === 'function' ? outsidePressFn : outsidePressProp;\n  const endedOrStartedInsideRef = React.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const touchStateRef = React.useRef(null);\n  const cancelDismissOnEndTimeout = useTimeout();\n  const insideReactTreeTimeout = useTimeout();\n  const isComposingRef = React.useRef(false);\n  const currentPointerTypeRef = React.useRef('');\n  const trackPointerType = useEventCallback(event => {\n    currentPointerTypeRef.current = event.pointerType;\n  });\n  const getOutsidePressEvent = useEventCallback(() => {\n    const type = currentPointerTypeRef.current;\n    const computedType = type === 'pen' || !type ? 'mouse' : type;\n    const resolved = typeof outsidePressEvent === 'function' ? outsidePressEvent() : outsidePressEvent;\n    if (typeof resolved === 'string') {\n      return resolved;\n    }\n    return resolved[computedType];\n  });\n  const closeOnEscapeKeyDown = useEventCallback(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n\n    // Wait until IME is settled. Pressing `Escape` while composing should\n    // close the compose menu, but not the floating element.\n    if (isComposingRef.current) {\n      return;\n    }\n    const nodeId = dataRef.current.floatingContext?.nodeId;\n    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          if (child.context?.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    const native = isReactEvent(event) ? event.nativeEvent : event;\n    const eventDetails = createChangeEventDetails('escape-key', native);\n    onOpenChange(false, eventDetails);\n    if (!escapeKeyBubbles && !eventDetails.isPropagationAllowed) {\n      event.stopPropagation();\n    }\n  });\n  const shouldIgnoreEvent = useEventCallback(event => {\n    const computedOutsidePressEvent = getOutsidePressEvent();\n    return computedOutsidePressEvent === 'intentional' && event.type !== 'click' || computedOutsidePressEvent === 'sloppy' && event.type === 'click';\n  });\n  const closeOnEscapeKeyDownCapture = useEventCallback(event => {\n    const callback = () => {\n      closeOnEscapeKeyDown(event);\n      getTarget(event)?.removeEventListener('keydown', callback);\n    };\n    getTarget(event)?.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEventCallback((event, endedOrStartedInside = false) => {\n    if (shouldIgnoreEvent(event)) {\n      return;\n    }\n\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = dataRef.current.insideReactTree;\n    dataRef.current.insideReactTree = false;\n    if (getOutsidePressEvent() === 'intentional' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n    const inertSelector = `[${createAttribute('inert')}]`;\n    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = isElement(target) ? target : null;\n    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {\n      const nextParent = getParentNode(targetRootAncestor);\n      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && isElement(target) && !isRootElement(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !contains(target, elements.floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !contains(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target)) {\n      const lastTraversableNode = isLastTraversableNode(target);\n      const style = getComputedStyle(target);\n      const scrollRe = /auto|scroll/;\n      const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);\n      const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);\n      const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      const isRTL = style.direction === 'rtl';\n\n      // Check click position relative to scrollbar.\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      const pressedVerticalScrollbar = canScrollY && (isRTL ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);\n      const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;\n      if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {\n        return;\n      }\n    }\n    const nodeId = dataRef.current.floatingContext?.nodeId;\n    const targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some(node => isEventTargetWithin(event, node.context?.elements.floating));\n    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        if (child.context?.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, createChangeEventDetails('outside-press', event));\n  });\n  const handlePointerDown = useEventCallback(event => {\n    if (getOutsidePressEvent() !== 'sloppy' || !open || !enabled || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference)) {\n      return;\n    }\n    if (event.pointerType === 'touch') {\n      touchStateRef.current = {\n        startTime: Date.now(),\n        startX: event.clientX,\n        startY: event.clientY,\n        dismissOnPointerUp: false,\n        dismissOnMouseDown: true\n      };\n      cancelDismissOnEndTimeout.start(1000, () => {\n        if (touchStateRef.current) {\n          touchStateRef.current.dismissOnPointerUp = false;\n          touchStateRef.current.dismissOnMouseDown = false;\n        }\n      });\n      return;\n    }\n    closeOnPressOutside(event);\n  });\n  const closeOnPressOutsideCapture = useEventCallback(event => {\n    // When click outside is lazy (`up` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (shouldIgnoreEvent(event)) {\n      return;\n    }\n    cancelDismissOnEndTimeout.clear();\n    if (event.type === 'mousedown' && touchStateRef.current && !touchStateRef.current.dismissOnMouseDown) {\n      return;\n    }\n    const callback = () => {\n      if (event.type === 'pointerdown') {\n        handlePointerDown(event);\n      } else {\n        closeOnPressOutside(event, endedOrStartedInside);\n      }\n      getTarget(event)?.removeEventListener(event.type, callback);\n    };\n    getTarget(event)?.addEventListener(event.type, callback);\n  });\n  const handlePointerMove = useEventCallback(event => {\n    if (getOutsidePressEvent() !== 'sloppy' || event.pointerType !== 'touch' || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference)) {\n      return;\n    }\n    const deltaX = Math.abs(event.clientX - touchStateRef.current.startX);\n    const deltaY = Math.abs(event.clientY - touchStateRef.current.startY);\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    if (distance > 5) {\n      touchStateRef.current.dismissOnPointerUp = true;\n    }\n    if (distance > 10) {\n      closeOnPressOutside(event);\n      cancelDismissOnEndTimeout.clear();\n      touchStateRef.current = null;\n    }\n  });\n  const handlePointerUp = useEventCallback(event => {\n    if (getOutsidePressEvent() !== 'sloppy' || event.pointerType !== 'touch' || !touchStateRef.current || isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference)) {\n      return;\n    }\n    if (touchStateRef.current.dismissOnPointerUp) {\n      closeOnPressOutside(event);\n    }\n    cancelDismissOnEndTimeout.clear();\n    touchStateRef.current = null;\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return undefined;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    const compositionTimeout = new Timeout();\n    function onScroll(event) {\n      onOpenChange(false, createChangeEventDetails('none', event));\n    }\n    function handleCompositionStart() {\n      compositionTimeout.clear();\n      isComposingRef.current = true;\n    }\n    function handleCompositionEnd() {\n      // Safari fires `compositionend` before `keydown`, so we need to wait\n      // until the next tick to set `isComposing` to `false`.\n      // https://bugs.webkit.org/show_bug.cgi?id=165004\n      compositionTimeout.start(\n      // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.\n      // Only apply to WebKit for the test to remain 0ms.\n      isWebKit() ? 5 : 0, () => {\n        isComposingRef.current = false;\n      });\n    }\n    const doc = getDocument(elements.floating);\n    doc.addEventListener('pointerdown', trackPointerType, true);\n    if (escapeKey) {\n      doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      doc.addEventListener('compositionstart', handleCompositionStart);\n      doc.addEventListener('compositionend', handleCompositionEnd);\n    }\n    if (outsidePress) {\n      doc.addEventListener('click', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      doc.addEventListener('pointerdown', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      doc.addEventListener('pointermove', handlePointerMove, outsidePressCapture);\n      doc.addEventListener('pointerup', handlePointerUp, outsidePressCapture);\n      doc.addEventListener('mousedown', closeOnPressOutsideCapture, outsidePressCapture);\n    }\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(elements.domReference)) {\n        ancestors = getOverflowAncestors(elements.domReference);\n      }\n      if (isElement(elements.floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));\n      }\n      if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => ancestor !== doc.defaultView?.visualViewport);\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      doc.removeEventListener('pointerdown', trackPointerType, true);\n      if (escapeKey) {\n        doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        doc.removeEventListener('compositionstart', handleCompositionStart);\n        doc.removeEventListener('compositionend', handleCompositionEnd);\n      }\n      if (outsidePress) {\n        doc.removeEventListener('click', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        doc.removeEventListener('pointerdown', outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        doc.removeEventListener('pointermove', handlePointerMove, outsidePressCapture);\n        doc.removeEventListener('pointerup', handlePointerUp, outsidePressCapture);\n        doc.removeEventListener('mousedown', closeOnPressOutsideCapture, outsidePressCapture);\n      }\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n      compositionTimeout.clear();\n    };\n  }, [dataRef, elements, escapeKey, outsidePress, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture, handlePointerDown, handlePointerMove, handlePointerUp, trackPointerType]);\n  React.useEffect(() => {\n    dataRef.current.insideReactTree = false;\n  }, [dataRef, outsidePress]);\n  const reference = React.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    ...(referencePress && {\n      [bubbleHandlerKeys[referencePressEvent]]: event => {\n        onOpenChange(false, createChangeEventDetails('trigger-press', event.nativeEvent));\n      },\n      ...(referencePressEvent !== 'intentional' && {\n        onClick(event) {\n          onOpenChange(false, createChangeEventDetails('trigger-press', event.nativeEvent));\n        }\n      })\n    })\n  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);\n  const handlePressedInside = useEventCallback(event => {\n    const target = getTarget(event.nativeEvent);\n    if (!contains(elements.floating, target) || event.button !== 0) {\n      return;\n    }\n    endedOrStartedInsideRef.current = true;\n  });\n  const handleCaptureInside = useEventCallback(() => {\n    dataRef.current.insideReactTree = true;\n    insideReactTreeTimeout.start(0, () => {\n      dataRef.current.insideReactTree = false;\n    });\n  });\n  const floating = React.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    onMouseDown: handlePressedInside,\n    onMouseUp: handlePressedInside,\n    onPointerDownCapture: handleCaptureInside,\n    onMouseDownCapture: handleCaptureInside,\n    onClickCapture: handleCaptureInside,\n    onMouseUpCapture: handleCaptureInside\n  }), [closeOnEscapeKeyDown, handlePressedInside, handleCaptureInside]);\n  return React.useMemo(() => enabled ? {\n    reference,\n    floating\n  } : {}, [enabled, reference, floating]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}