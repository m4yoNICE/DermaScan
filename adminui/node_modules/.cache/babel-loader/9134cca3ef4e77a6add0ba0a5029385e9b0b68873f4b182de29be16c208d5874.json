{"ast":null,"code":"import { useRefWithInit } from \"./useRefWithInit.js\";\n\n/**\n * Merges refs into a single memoized callback ref or `null`.\n * This makes sure multiple refs are updated together and have the same value.\n *\n * This function accepts up to four refs. If you need to merge more, or have an unspecified number of refs to merge,\n * use `useMergedRefsN` instead.\n */\n\nexport function useMergedRefs(a, b, c, d) {\n  const forkRef = useRefWithInit(createForkRef).current;\n  if (didChange(forkRef, a, b, c, d)) {\n    update(forkRef, [a, b, c, d]);\n  }\n  return forkRef.callback;\n}\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n *\n * If you need to merge a fixed number (up to four) of refs, use `useMergedRefs` instead for better performance.\n */\nexport function useMergedRefsN(refs) {\n  const forkRef = useRefWithInit(createForkRef).current;\n  if (didChangeN(forkRef, refs)) {\n    update(forkRef, refs);\n  }\n  return forkRef.callback;\n}\nfunction createForkRef() {\n  return {\n    callback: null,\n    cleanup: null,\n    refs: []\n  };\n}\nfunction didChange(forkRef, a, b, c, d) {\n  // prettier-ignore\n  return forkRef.refs[0] !== a || forkRef.refs[1] !== b || forkRef.refs[2] !== c || forkRef.refs[3] !== d;\n}\nfunction didChangeN(forkRef, newRefs) {\n  return forkRef.refs.length !== newRefs.length || forkRef.refs.some((ref, index) => ref !== newRefs[index]);\n}\nfunction update(forkRef, refs) {\n  forkRef.refs = refs;\n  if (refs.every(ref => ref == null)) {\n    forkRef.callback = null;\n    return;\n  }\n  forkRef.callback = instance => {\n    if (forkRef.cleanup) {\n      forkRef.cleanup();\n      forkRef.cleanup = null;\n    }\n    if (instance != null) {\n      const cleanupCallbacks = Array(refs.length).fill(null);\n      for (let i = 0; i < refs.length; i += 1) {\n        const ref = refs[i];\n        if (ref == null) {\n          continue;\n        }\n        switch (typeof ref) {\n          case 'function':\n            {\n              const refCleanup = ref(instance);\n              if (typeof refCleanup === 'function') {\n                cleanupCallbacks[i] = refCleanup;\n              }\n              break;\n            }\n          case 'object':\n            {\n              ref.current = instance;\n              break;\n            }\n          default:\n        }\n      }\n      forkRef.cleanup = () => {\n        for (let i = 0; i < refs.length; i += 1) {\n          const ref = refs[i];\n          if (ref == null) {\n            continue;\n          }\n          switch (typeof ref) {\n            case 'function':\n              {\n                const cleanupCallback = cleanupCallbacks[i];\n                if (typeof cleanupCallback === 'function') {\n                  cleanupCallback();\n                } else {\n                  ref(null);\n                }\n                break;\n              }\n            case 'object':\n              {\n                ref.current = null;\n                break;\n              }\n            default:\n          }\n        }\n      };\n    }\n  };\n}","map":{"version":3,"names":["useRefWithInit","useMergedRefs","a","b","c","d","forkRef","createForkRef","current","didChange","update","callback","useMergedRefsN","refs","didChangeN","cleanup","newRefs","length","some","ref","index","every","instance","cleanupCallbacks","Array","fill","i","refCleanup","cleanupCallback"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/utils/esm/useMergedRefs.js"],"sourcesContent":["import { useRefWithInit } from \"./useRefWithInit.js\";\n\n/**\n * Merges refs into a single memoized callback ref or `null`.\n * This makes sure multiple refs are updated together and have the same value.\n *\n * This function accepts up to four refs. If you need to merge more, or have an unspecified number of refs to merge,\n * use `useMergedRefsN` instead.\n */\n\nexport function useMergedRefs(a, b, c, d) {\n  const forkRef = useRefWithInit(createForkRef).current;\n  if (didChange(forkRef, a, b, c, d)) {\n    update(forkRef, [a, b, c, d]);\n  }\n  return forkRef.callback;\n}\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n *\n * If you need to merge a fixed number (up to four) of refs, use `useMergedRefs` instead for better performance.\n */\nexport function useMergedRefsN(refs) {\n  const forkRef = useRefWithInit(createForkRef).current;\n  if (didChangeN(forkRef, refs)) {\n    update(forkRef, refs);\n  }\n  return forkRef.callback;\n}\nfunction createForkRef() {\n  return {\n    callback: null,\n    cleanup: null,\n    refs: []\n  };\n}\nfunction didChange(forkRef, a, b, c, d) {\n  // prettier-ignore\n  return forkRef.refs[0] !== a || forkRef.refs[1] !== b || forkRef.refs[2] !== c || forkRef.refs[3] !== d;\n}\nfunction didChangeN(forkRef, newRefs) {\n  return forkRef.refs.length !== newRefs.length || forkRef.refs.some((ref, index) => ref !== newRefs[index]);\n}\nfunction update(forkRef, refs) {\n  forkRef.refs = refs;\n  if (refs.every(ref => ref == null)) {\n    forkRef.callback = null;\n    return;\n  }\n  forkRef.callback = instance => {\n    if (forkRef.cleanup) {\n      forkRef.cleanup();\n      forkRef.cleanup = null;\n    }\n    if (instance != null) {\n      const cleanupCallbacks = Array(refs.length).fill(null);\n      for (let i = 0; i < refs.length; i += 1) {\n        const ref = refs[i];\n        if (ref == null) {\n          continue;\n        }\n        switch (typeof ref) {\n          case 'function':\n            {\n              const refCleanup = ref(instance);\n              if (typeof refCleanup === 'function') {\n                cleanupCallbacks[i] = refCleanup;\n              }\n              break;\n            }\n          case 'object':\n            {\n              ref.current = instance;\n              break;\n            }\n          default:\n        }\n      }\n      forkRef.cleanup = () => {\n        for (let i = 0; i < refs.length; i += 1) {\n          const ref = refs[i];\n          if (ref == null) {\n            continue;\n          }\n          switch (typeof ref) {\n            case 'function':\n              {\n                const cleanupCallback = cleanupCallbacks[i];\n                if (typeof cleanupCallback === 'function') {\n                  cleanupCallback();\n                } else {\n                  ref(null);\n                }\n                break;\n              }\n            case 'object':\n              {\n                ref.current = null;\n                break;\n              }\n            default:\n          }\n        }\n      };\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}