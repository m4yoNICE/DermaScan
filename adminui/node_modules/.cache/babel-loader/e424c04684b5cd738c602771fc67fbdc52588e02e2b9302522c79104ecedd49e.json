{"ast":null,"code":"import * as React from 'react';\nimport { tabbable, isTabbable, focusable } from 'tabbable';\nimport { getNodeName, isHTMLElement } from '@floating-ui/utils/dom';\nimport { useMergedRefs } from '@base-ui-components/utils/useMergedRefs';\nimport { useLatestRef } from '@base-ui-components/utils/useLatestRef';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { visuallyHidden } from '@base-ui-components/utils/visuallyHidden';\nimport { useTimeout } from '@base-ui-components/utils/useTimeout';\nimport { useAnimationFrame } from '@base-ui-components/utils/useAnimationFrame';\nimport { ownerWindow } from '@base-ui-components/utils/owner';\nimport { FocusGuard } from \"../../utils/FocusGuard.js\";\nimport { activeElement, contains, getDocument, getTarget, isTypeableCombobox, isVirtualClick, isVirtualPointerEvent, stopEvent, getNodeAncestors, getNodeChildren, getFloatingFocusElement, getTabbableOptions, isOutsideEvent, getNextTabbable, getPreviousTabbable } from \"../utils.js\";\nimport { createChangeEventDetails } from \"../../utils/createBaseUIEventDetails.js\";\nimport { createAttribute } from \"../utils/createAttribute.js\";\nimport { enqueueFocus } from \"../utils/enqueueFocus.js\";\nimport { markOthers } from \"../utils/markOthers.js\";\nimport { usePortalContext } from \"./FloatingPortal.js\";\nimport { useFloatingTree } from \"./FloatingTree.js\";\nimport { CLICK_TRIGGER_IDENTIFIER } from \"../../utils/constants.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nfunction getEventType(event, lastInteractionType) {\n  const win = ownerWindow(event.target);\n  if (event instanceof win.KeyboardEvent) {\n    return 'keyboard';\n  }\n  if (event instanceof win.FocusEvent) {\n    // Focus events can be caused by a preceding pointer interaction (e.g., focusout on outside press).\n    // Prefer the last known pointer type if provided, else treat as keyboard.\n    return lastInteractionType || 'keyboard';\n  }\n  if ('pointerType' in event) {\n    return event.pointerType || 'keyboard';\n  }\n  if ('touches' in event) {\n    return 'touch';\n  }\n  if (event instanceof win.MouseEvent) {\n    // onClick events may not contain pointer events, and will fall through to here\n    return lastInteractionType || (event.detail === 0 ? 'keyboard' : 'mouse');\n  }\n  return '';\n}\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction clearDisconnectedPreviouslyFocusedElements() {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n}\nfunction addPreviouslyFocusedElement(element) {\n  clearDisconnectedPreviouslyFocusedElements();\n  if (element && getNodeName(element) !== 'body') {\n    previouslyFocusedElements.push(element);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n    }\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  clearDisconnectedPreviouslyFocusedElements();\n  return previouslyFocusedElements[previouslyFocusedElements.length - 1];\n}\nfunction getFirstTabbableElement(container) {\n  if (!container) {\n    return null;\n  }\n  const tabbableOptions = getTabbableOptions();\n  if (isTabbable(container, tabbableOptions)) {\n    return container;\n  }\n  return tabbable(container, tabbableOptions)[0] || container;\n}\nfunction handleTabIndex(floatingFocusElement, orderRef) {\n  if (!orderRef.current.includes('floating') && !floatingFocusElement.getAttribute('role')?.includes('dialog')) {\n    return;\n  }\n  const options = getTabbableOptions();\n  const focusableElements = focusable(floatingFocusElement, options);\n  const tabbableContent = focusableElements.filter(element => {\n    const dataTabIndex = element.getAttribute('data-tabindex') || '';\n    return isTabbable(element, options) || element.hasAttribute('data-tabindex') && !dataTabIndex.startsWith('-');\n  });\n  const tabIndex = floatingFocusElement.getAttribute('tabindex');\n  if (orderRef.current.includes('floating') || tabbableContent.length === 0) {\n    if (tabIndex !== '0') {\n      floatingFocusElement.setAttribute('tabindex', '0');\n    }\n  } else if (tabIndex !== '-1' || floatingFocusElement.hasAttribute('data-tabindex') && floatingFocusElement.getAttribute('data-tabindex') !== '-1') {\n    floatingFocusElement.setAttribute('tabindex', '-1');\n    floatingFocusElement.setAttribute('data-tabindex', '-1');\n  }\n}\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n * @internal\n */\nexport function FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    initialFocus = true,\n    returnFocus = true,\n    restoreFocus = false,\n    modal = true,\n    closeOnFocusOut = true,\n    openInteractionType = '',\n    getInsideElements: getInsideElementsProp = () => []\n  } = props;\n  const {\n    open,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const getNodeId = useEventCallback(() => dataRef.current.floatingContext?.nodeId);\n  const getInsideElements = useEventCallback(getInsideElementsProp);\n  const ignoreInitialFocus = initialFocus === false;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const openInteractionTypeRef = useLatestRef(openInteractionType);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const isPointerDownRef = React.useRef(false);\n  const tabbableIndexRef = React.useRef(-1);\n  const closeTypeRef = React.useRef('');\n  const lastInteractionTypeRef = React.useRef('');\n  const blurTimeout = useTimeout();\n  const pointerDownTimeout = useTimeout();\n  const restoreFocusFrame = useAnimationFrame();\n  const isInsidePortal = portalContext != null;\n  const floatingFocusElement = getFloatingFocusElement(floating);\n  const getTabbableContent = useEventCallback((container = floatingFocusElement) => {\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  });\n  const getTabbableElements = useEventCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(() => content).filter(Boolean).flat();\n  });\n  React.useEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!modal) {\n      return undefined;\n    }\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          stopEvent(event);\n        }\n      }\n    }\n    const doc = getDocument(floatingFocusElement);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!floating) {\n      return undefined;\n    }\n    function handleFocusIn(event) {\n      const target = getTarget(event);\n      const tabbableContent = getTabbableContent();\n      const tabbableIndex = tabbableContent.indexOf(target);\n      if (tabbableIndex !== -1) {\n        tabbableIndexRef.current = tabbableIndex;\n      }\n    }\n    floating.addEventListener('focusin', handleFocusIn);\n    return () => {\n      floating.removeEventListener('focusin', handleFocusIn);\n    };\n  }, [disabled, floating, getTabbableContent]);\n\n  // Track the last interaction type at the document level to disambiguate focus events\n  React.useEffect(() => {\n    if (disabled || !open) {\n      return undefined;\n    }\n    const doc = getDocument(floatingFocusElement);\n    function onPointerDown(event) {\n      lastInteractionTypeRef.current = event.pointerType || 'keyboard';\n    }\n    function onKeyDown() {\n      lastInteractionTypeRef.current = 'keyboard';\n    }\n    doc.addEventListener('pointerdown', onPointerDown, true);\n    doc.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      doc.removeEventListener('pointerdown', onPointerDown, true);\n      doc.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [disabled, floating, domReference, floatingFocusElement, open]);\n  React.useEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!closeOnFocusOut) {\n      return undefined;\n    }\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      pointerDownTimeout.start(0, () => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      const currentTarget = event.currentTarget;\n      const target = getTarget(event);\n      queueMicrotask(() => {\n        const nodeId = getNodeId();\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext?.portalNode, relatedTarget) || relatedTarget?.hasAttribute(createAttribute('focus-guard')) || tree && (getNodeChildren(tree.nodesRef.current, nodeId).find(node => contains(node.context?.elements.floating, relatedTarget) || contains(node.context?.elements.domReference, relatedTarget)) || getNodeAncestors(tree.nodesRef.current, nodeId).find(node => [node.context?.elements.floating, getFloatingFocusElement(node.context?.elements.floating)].includes(relatedTarget) || node.context?.elements.domReference === relatedTarget)));\n        if (currentTarget === domReference && floatingFocusElement) {\n          handleTabIndex(floatingFocusElement, orderRef);\n        }\n\n        // Restore focus to the previous tabbable element index to prevent\n        // focus from being lost outside the floating tree.\n        if (restoreFocus && currentTarget !== domReference && !target?.isConnected && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {\n          // Let `FloatingPortal` effect knows that focus is still inside the\n          // floating tree.\n          if (isHTMLElement(floatingFocusElement)) {\n            floatingFocusElement.focus();\n            // If explicitly requested to restore focus to the popup container, do not search\n            // for the next/previous tabbable element.\n            if (restoreFocus === 'popup') {\n              // If the element is removed on pointerdown, focus tries to move it,\n              // but since it's removed at the same time, focus gets lost as it\n              // happens after the .focus() call above.\n              // In this case, focus needs to be moved asynchronously.\n              restoreFocusFrame.request(() => {\n                floatingFocusElement.focus();\n              });\n              return;\n            }\n          }\n          const prevTabbableIndex = tabbableIndexRef.current;\n          const tabbableContent = getTabbableContent();\n          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;\n          if (isHTMLElement(nodeToFocus)) {\n            nodeToFocus.focus();\n          }\n        }\n\n        // https://github.com/floating-ui/floating-ui/issues/3060\n        if (dataRef.current.insideReactTree) {\n          dataRef.current.insideReactTree = false;\n          return;\n        }\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && (\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        // For an \"untrapped\" typeable combobox (input role=combobox with\n        // initialFocus=false), re-opening the popup and tabbing out should still close it even\n        // when the previously focused element (e.g. the next tabbable outside the popup) is\n        // focused again. Otherwise, the popup remains open on the second Tab sequence:\n        // click input -> Tab (closes) -> click input -> Tab.\n        // Allow closing when `isUntrappedTypeableCombobox` regardless of the previously focused element.\n        isUntrappedTypeableCombobox || relatedTarget !== getPreviouslyFocusedElement())) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, createChangeEventDetails('focus-out', event));\n        }\n      });\n    }\n    function markInsideReactTree() {\n      dataRef.current.insideReactTree = true;\n      blurTimeout.start(0, () => {\n        dataRef.current.insideReactTree = false;\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      floating.addEventListener('focusout', handleFocusOutside);\n      if (portalContext) {\n        floating.addEventListener('focusout', markInsideReactTree, true);\n      }\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        floating.removeEventListener('focusout', handleFocusOutside);\n        if (portalContext) {\n          floating.removeEventListener('focusout', markInsideReactTree, true);\n        }\n      };\n    }\n    return undefined;\n  }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef, dataRef, blurTimeout, pointerDownTimeout, restoreFocusFrame]);\n  const beforeGuardRef = React.useRef(null);\n  const afterGuardRef = React.useRef(null);\n  const mergedBeforeGuardRef = useMergedRefs(beforeGuardRef, portalContext?.beforeInsideRef);\n  const mergedAfterGuardRef = useMergedRefs(afterGuardRef, portalContext?.afterInsideRef);\n  React.useEffect(() => {\n    if (disabled || !floating || !open) {\n      return undefined;\n    }\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from(portalContext?.portalNode?.querySelectorAll(`[${createAttribute('portal')}]`) || []);\n    const ancestors = tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : [];\n    const rootAncestorComboboxDomReference = ancestors.find(node => isTypeableCombobox(node.context?.elements.domReference || null))?.context?.elements.domReference;\n    const insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext?.beforeOutsideRef.current, portalContext?.afterOutsideRef.current, isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n    const cleanup = markOthers(insideElements, modal || isUntrappedTypeableCombobox);\n    return () => {\n      cleanup();\n    };\n  }, [open, disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, tree, getNodeId, getInsideElements]);\n  useIsoLayoutEffect(() => {\n    if (disabled || !isHTMLElement(floatingFocusElement)) {\n      return;\n    }\n    const doc = getDocument(floatingFocusElement);\n    const previouslyFocusedElement = activeElement(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floatingFocusElement);\n      const initialFocusValueOrFn = initialFocusRef.current;\n      const resolvedInitialFocus = typeof initialFocusValueOrFn === 'function' ? initialFocusValueOrFn(openInteractionTypeRef.current || '') : initialFocusValueOrFn;\n\n      // `null` should fallback to default behavior in case of an empty ref.\n      if (resolvedInitialFocus === undefined || resolvedInitialFocus === false) {\n        return;\n      }\n      let elToFocus;\n      if (resolvedInitialFocus === true || resolvedInitialFocus === null) {\n        elToFocus = focusableElements[0] || floatingFocusElement;\n      } else if ('current' in resolvedInitialFocus) {\n        elToFocus = resolvedInitialFocus.current;\n      } else {\n        elToFocus = resolvedInitialFocus;\n      }\n      elToFocus = elToFocus || focusableElements[0] || floatingFocusElement;\n      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);\n      if (!focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floatingFocusElement\n        });\n      }\n    });\n  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef, openInteractionTypeRef]);\n  useIsoLayoutEffect(() => {\n    if (disabled || !floatingFocusElement) {\n      return undefined;\n    }\n    const doc = getDocument(floatingFocusElement);\n    const previouslyFocusedElement = activeElement(doc);\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChangeLocal(details) {\n      if (!details.open) {\n        closeTypeRef.current = getEventType(details.nativeEvent, lastInteractionTypeRef.current);\n      }\n      if (details.reason === 'trigger-hover' && details.nativeEvent.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (details.reason !== 'outside-press') {\n        return;\n      }\n      if (details.nested) {\n        preventReturnFocusRef.current = false;\n      } else if (isVirtualClick(details.nativeEvent) || isVirtualPointerEvent(details.nativeEvent)) {\n        preventReturnFocusRef.current = false;\n      } else {\n        let isPreventScrollSupported = false;\n        document.createElement('div').focus({\n          get preventScroll() {\n            isPreventScrollSupported = true;\n            return false;\n          }\n        });\n        if (isPreventScrollSupported) {\n          preventReturnFocusRef.current = false;\n        } else {\n          preventReturnFocusRef.current = true;\n        }\n      }\n    }\n    events.on('openchange', onOpenChangeLocal);\n    const fallbackEl = doc.createElement('span');\n    fallbackEl.setAttribute('tabindex', '-1');\n    fallbackEl.setAttribute('aria-hidden', 'true');\n    Object.assign(fallbackEl.style, visuallyHidden);\n    if (isInsidePortal && domReference) {\n      domReference.insertAdjacentElement('afterend', fallbackEl);\n    }\n    function getReturnElement() {\n      const returnFocusValueOrFn = returnFocusRef.current;\n      let resolvedReturnFocusValue = typeof returnFocusValueOrFn === 'function' ? returnFocusValueOrFn(closeTypeRef.current) : returnFocusValueOrFn;\n\n      // `null` should fallback to default behavior in case of an empty ref.\n      if (resolvedReturnFocusValue === undefined || resolvedReturnFocusValue === false) {\n        return null;\n      }\n      if (resolvedReturnFocusValue === null) {\n        resolvedReturnFocusValue = true;\n      }\n      if (typeof resolvedReturnFocusValue === 'boolean') {\n        const el = domReference || getPreviouslyFocusedElement();\n        return el && el.isConnected ? el : fallbackEl;\n      }\n      const fallback = domReference || getPreviouslyFocusedElement() || fallbackEl;\n      if ('current' in resolvedReturnFocusValue) {\n        return resolvedReturnFocusValue.current || fallback;\n      }\n      return resolvedReturnFocusValue || fallback;\n    }\n    return () => {\n      events.off('openchange', onOpenChangeLocal);\n      const activeEl = activeElement(doc);\n      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getNodeChildren(tree.nodesRef.current, getNodeId(), false).some(node => contains(node.context?.elements.floating, activeEl));\n      const returnElement = getReturnElement();\n      queueMicrotask(() => {\n        // This is `returnElement`, if it's tabbable, or its first tabbable child.\n        const tabbableReturnElement = getFirstTabbableElement(returnElement);\n        const hasExplicitReturnFocus = typeof returnFocusRef.current !== 'boolean';\n        if (\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(tabbableReturnElement) && (\n        // If the focus moved somewhere else after mount, avoid returning focus\n        // since it likely entered a different element which should be\n        // respected: https://github.com/floating-ui/floating-ui/issues/2607\n        !hasExplicitReturnFocus && tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n          tabbableReturnElement.focus({\n            preventScroll: true\n          });\n        }\n        fallbackEl.remove();\n      });\n    };\n  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events, tree, isInsidePortal, domReference, getNodeId]);\n  React.useEffect(() => {\n    // The `returnFocus` cleanup behavior is inside a microtask; ensure we\n    // wait for it to complete before resetting the flag.\n    queueMicrotask(() => {\n      preventReturnFocusRef.current = false;\n    });\n  }, [disabled]);\n  React.useEffect(() => {\n    if (disabled || !open) {\n      return undefined;\n    }\n    function handlePointerDown(event) {\n      const target = getTarget(event);\n      if (target?.closest(`[${CLICK_TRIGGER_IDENTIFIER}]`)) {\n        isPointerDownRef.current = true;\n      }\n    }\n    const doc = getDocument(floatingFocusElement);\n    doc.addEventListener('pointerdown', handlePointerDown, true);\n    return () => {\n      doc.removeEventListener('pointerdown', handlePointerDown, true);\n    };\n  }, [disabled, open, floatingFocusElement]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  useIsoLayoutEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!portalContext) {\n      return undefined;\n    }\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      domReference\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, closeOnFocusOut, domReference]);\n  useIsoLayoutEffect(() => {\n    if (disabled || !floatingFocusElement) {\n      return undefined;\n    }\n    handleTabIndex(floatingFocusElement, orderRef);\n    return () => {\n      queueMicrotask(clearDisconnectedPreviouslyFocusedElements);\n    };\n  }, [disabled, floatingFocusElement, orderRef]);\n  const shouldRenderGuards = !disabled && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [shouldRenderGuards && /*#__PURE__*/_jsx(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: mergedBeforeGuardRef,\n      onFocus: event => {\n        if (modal) {\n          const els = getTabbableElements();\n          enqueueFocus(els[els.length - 1]);\n        } else if (portalContext?.preserveTabOrder && portalContext.portalNode) {\n          preventReturnFocusRef.current = false;\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const nextTabbable = getNextTabbable(domReference);\n            nextTabbable?.focus();\n          } else {\n            portalContext.beforeOutsideRef.current?.focus();\n          }\n        }\n      }\n    }), children, shouldRenderGuards && /*#__PURE__*/_jsx(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: mergedAfterGuardRef,\n      onFocus: event => {\n        if (modal) {\n          enqueueFocus(getTabbableElements()[0]);\n        } else if (portalContext?.preserveTabOrder && portalContext.portalNode) {\n          if (closeOnFocusOut) {\n            preventReturnFocusRef.current = true;\n          }\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const prevTabbable = getPreviousTabbable(domReference);\n            prevTabbable?.focus();\n          } else {\n            portalContext.afterOutsideRef.current?.focus();\n          }\n        }\n      }\n    })]\n  });\n}","map":{"version":3,"names":["React","tabbable","isTabbable","focusable","getNodeName","isHTMLElement","useMergedRefs","useLatestRef","useEventCallback","useIsoLayoutEffect","visuallyHidden","useTimeout","useAnimationFrame","ownerWindow","FocusGuard","activeElement","contains","getDocument","getTarget","isTypeableCombobox","isVirtualClick","isVirtualPointerEvent","stopEvent","getNodeAncestors","getNodeChildren","getFloatingFocusElement","getTabbableOptions","isOutsideEvent","getNextTabbable","getPreviousTabbable","createChangeEventDetails","createAttribute","enqueueFocus","markOthers","usePortalContext","useFloatingTree","CLICK_TRIGGER_IDENTIFIER","jsx","_jsx","jsxs","_jsxs","getEventType","event","lastInteractionType","win","target","KeyboardEvent","FocusEvent","pointerType","MouseEvent","detail","LIST_LIMIT","previouslyFocusedElements","clearDisconnectedPreviouslyFocusedElements","filter","el","isConnected","addPreviouslyFocusedElement","element","push","length","slice","getPreviouslyFocusedElement","getFirstTabbableElement","container","tabbableOptions","handleTabIndex","floatingFocusElement","orderRef","current","includes","getAttribute","options","focusableElements","tabbableContent","dataTabIndex","hasAttribute","startsWith","tabIndex","setAttribute","FloatingFocusManager","props","context","children","disabled","order","initialFocus","returnFocus","restoreFocus","modal","closeOnFocusOut","openInteractionType","getInsideElements","getInsideElementsProp","open","onOpenChange","events","dataRef","elements","domReference","floating","getNodeId","floatingContext","nodeId","ignoreInitialFocus","isUntrappedTypeableCombobox","initialFocusRef","returnFocusRef","openInteractionTypeRef","tree","portalContext","startDismissButtonRef","useRef","endDismissButtonRef","preventReturnFocusRef","isPointerDownRef","tabbableIndexRef","closeTypeRef","lastInteractionTypeRef","blurTimeout","pointerDownTimeout","restoreFocusFrame","isInsidePortal","getTabbableContent","getTabbableElements","content","map","Boolean","flat","useEffect","undefined","onKeyDown","key","doc","addEventListener","removeEventListener","handleFocusIn","tabbableIndex","indexOf","onPointerDown","handlePointerDown","start","handleFocusOutside","relatedTarget","currentTarget","queueMicrotask","movedToUnrelatedNode","portalNode","nodesRef","find","node","body","focus","request","prevTabbableIndex","nodeToFocus","insideReactTree","markInsideReactTree","beforeGuardRef","afterGuardRef","mergedBeforeGuardRef","beforeInsideRef","mergedAfterGuardRef","afterInsideRef","portalNodes","Array","from","querySelectorAll","ancestors","rootAncestorComboboxDomReference","insideElements","beforeOutsideRef","afterOutsideRef","x","cleanup","previouslyFocusedElement","initialFocusValueOrFn","resolvedInitialFocus","elToFocus","focusAlreadyInsideFloatingEl","preventScroll","onOpenChangeLocal","details","nativeEvent","reason","type","nested","isPreventScrollSupported","document","createElement","on","fallbackEl","Object","assign","style","insertAdjacentElement","getReturnElement","returnFocusValueOrFn","resolvedReturnFocusValue","fallback","off","activeEl","isFocusInsideFloatingTree","some","returnElement","tabbableReturnElement","hasExplicitReturnFocus","remove","closest","setFocusManagerState","shouldRenderGuards","Fragment","ref","onFocus","els","preserveTabOrder","nextTabbable","prevTabbable"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/floating-ui-react/components/FloatingFocusManager.js"],"sourcesContent":["import * as React from 'react';\nimport { tabbable, isTabbable, focusable } from 'tabbable';\nimport { getNodeName, isHTMLElement } from '@floating-ui/utils/dom';\nimport { useMergedRefs } from '@base-ui-components/utils/useMergedRefs';\nimport { useLatestRef } from '@base-ui-components/utils/useLatestRef';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { visuallyHidden } from '@base-ui-components/utils/visuallyHidden';\nimport { useTimeout } from '@base-ui-components/utils/useTimeout';\nimport { useAnimationFrame } from '@base-ui-components/utils/useAnimationFrame';\nimport { ownerWindow } from '@base-ui-components/utils/owner';\nimport { FocusGuard } from \"../../utils/FocusGuard.js\";\nimport { activeElement, contains, getDocument, getTarget, isTypeableCombobox, isVirtualClick, isVirtualPointerEvent, stopEvent, getNodeAncestors, getNodeChildren, getFloatingFocusElement, getTabbableOptions, isOutsideEvent, getNextTabbable, getPreviousTabbable } from \"../utils.js\";\nimport { createChangeEventDetails } from \"../../utils/createBaseUIEventDetails.js\";\nimport { createAttribute } from \"../utils/createAttribute.js\";\nimport { enqueueFocus } from \"../utils/enqueueFocus.js\";\nimport { markOthers } from \"../utils/markOthers.js\";\nimport { usePortalContext } from \"./FloatingPortal.js\";\nimport { useFloatingTree } from \"./FloatingTree.js\";\nimport { CLICK_TRIGGER_IDENTIFIER } from \"../../utils/constants.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nfunction getEventType(event, lastInteractionType) {\n  const win = ownerWindow(event.target);\n  if (event instanceof win.KeyboardEvent) {\n    return 'keyboard';\n  }\n  if (event instanceof win.FocusEvent) {\n    // Focus events can be caused by a preceding pointer interaction (e.g., focusout on outside press).\n    // Prefer the last known pointer type if provided, else treat as keyboard.\n    return lastInteractionType || 'keyboard';\n  }\n  if ('pointerType' in event) {\n    return event.pointerType || 'keyboard';\n  }\n  if ('touches' in event) {\n    return 'touch';\n  }\n  if (event instanceof win.MouseEvent) {\n    // onClick events may not contain pointer events, and will fall through to here\n    return lastInteractionType || (event.detail === 0 ? 'keyboard' : 'mouse');\n  }\n  return '';\n}\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction clearDisconnectedPreviouslyFocusedElements() {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n}\nfunction addPreviouslyFocusedElement(element) {\n  clearDisconnectedPreviouslyFocusedElements();\n  if (element && getNodeName(element) !== 'body') {\n    previouslyFocusedElements.push(element);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n    }\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  clearDisconnectedPreviouslyFocusedElements();\n  return previouslyFocusedElements[previouslyFocusedElements.length - 1];\n}\nfunction getFirstTabbableElement(container) {\n  if (!container) {\n    return null;\n  }\n  const tabbableOptions = getTabbableOptions();\n  if (isTabbable(container, tabbableOptions)) {\n    return container;\n  }\n  return tabbable(container, tabbableOptions)[0] || container;\n}\nfunction handleTabIndex(floatingFocusElement, orderRef) {\n  if (!orderRef.current.includes('floating') && !floatingFocusElement.getAttribute('role')?.includes('dialog')) {\n    return;\n  }\n  const options = getTabbableOptions();\n  const focusableElements = focusable(floatingFocusElement, options);\n  const tabbableContent = focusableElements.filter(element => {\n    const dataTabIndex = element.getAttribute('data-tabindex') || '';\n    return isTabbable(element, options) || element.hasAttribute('data-tabindex') && !dataTabIndex.startsWith('-');\n  });\n  const tabIndex = floatingFocusElement.getAttribute('tabindex');\n  if (orderRef.current.includes('floating') || tabbableContent.length === 0) {\n    if (tabIndex !== '0') {\n      floatingFocusElement.setAttribute('tabindex', '0');\n    }\n  } else if (tabIndex !== '-1' || floatingFocusElement.hasAttribute('data-tabindex') && floatingFocusElement.getAttribute('data-tabindex') !== '-1') {\n    floatingFocusElement.setAttribute('tabindex', '-1');\n    floatingFocusElement.setAttribute('data-tabindex', '-1');\n  }\n}\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n * @internal\n */\nexport function FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    initialFocus = true,\n    returnFocus = true,\n    restoreFocus = false,\n    modal = true,\n    closeOnFocusOut = true,\n    openInteractionType = '',\n    getInsideElements: getInsideElementsProp = () => []\n  } = props;\n  const {\n    open,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const getNodeId = useEventCallback(() => dataRef.current.floatingContext?.nodeId);\n  const getInsideElements = useEventCallback(getInsideElementsProp);\n  const ignoreInitialFocus = initialFocus === false;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const openInteractionTypeRef = useLatestRef(openInteractionType);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const isPointerDownRef = React.useRef(false);\n  const tabbableIndexRef = React.useRef(-1);\n  const closeTypeRef = React.useRef('');\n  const lastInteractionTypeRef = React.useRef('');\n  const blurTimeout = useTimeout();\n  const pointerDownTimeout = useTimeout();\n  const restoreFocusFrame = useAnimationFrame();\n  const isInsidePortal = portalContext != null;\n  const floatingFocusElement = getFloatingFocusElement(floating);\n  const getTabbableContent = useEventCallback((container = floatingFocusElement) => {\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  });\n  const getTabbableElements = useEventCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(() => content).filter(Boolean).flat();\n  });\n  React.useEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!modal) {\n      return undefined;\n    }\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          stopEvent(event);\n        }\n      }\n    }\n    const doc = getDocument(floatingFocusElement);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!floating) {\n      return undefined;\n    }\n    function handleFocusIn(event) {\n      const target = getTarget(event);\n      const tabbableContent = getTabbableContent();\n      const tabbableIndex = tabbableContent.indexOf(target);\n      if (tabbableIndex !== -1) {\n        tabbableIndexRef.current = tabbableIndex;\n      }\n    }\n    floating.addEventListener('focusin', handleFocusIn);\n    return () => {\n      floating.removeEventListener('focusin', handleFocusIn);\n    };\n  }, [disabled, floating, getTabbableContent]);\n\n  // Track the last interaction type at the document level to disambiguate focus events\n  React.useEffect(() => {\n    if (disabled || !open) {\n      return undefined;\n    }\n    const doc = getDocument(floatingFocusElement);\n    function onPointerDown(event) {\n      lastInteractionTypeRef.current = event.pointerType || 'keyboard';\n    }\n    function onKeyDown() {\n      lastInteractionTypeRef.current = 'keyboard';\n    }\n    doc.addEventListener('pointerdown', onPointerDown, true);\n    doc.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      doc.removeEventListener('pointerdown', onPointerDown, true);\n      doc.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [disabled, floating, domReference, floatingFocusElement, open]);\n  React.useEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!closeOnFocusOut) {\n      return undefined;\n    }\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      pointerDownTimeout.start(0, () => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      const currentTarget = event.currentTarget;\n      const target = getTarget(event);\n      queueMicrotask(() => {\n        const nodeId = getNodeId();\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext?.portalNode, relatedTarget) || relatedTarget?.hasAttribute(createAttribute('focus-guard')) || tree && (getNodeChildren(tree.nodesRef.current, nodeId).find(node => contains(node.context?.elements.floating, relatedTarget) || contains(node.context?.elements.domReference, relatedTarget)) || getNodeAncestors(tree.nodesRef.current, nodeId).find(node => [node.context?.elements.floating, getFloatingFocusElement(node.context?.elements.floating)].includes(relatedTarget) || node.context?.elements.domReference === relatedTarget)));\n        if (currentTarget === domReference && floatingFocusElement) {\n          handleTabIndex(floatingFocusElement, orderRef);\n        }\n\n        // Restore focus to the previous tabbable element index to prevent\n        // focus from being lost outside the floating tree.\n        if (restoreFocus && currentTarget !== domReference && !target?.isConnected && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {\n          // Let `FloatingPortal` effect knows that focus is still inside the\n          // floating tree.\n          if (isHTMLElement(floatingFocusElement)) {\n            floatingFocusElement.focus();\n            // If explicitly requested to restore focus to the popup container, do not search\n            // for the next/previous tabbable element.\n            if (restoreFocus === 'popup') {\n              // If the element is removed on pointerdown, focus tries to move it,\n              // but since it's removed at the same time, focus gets lost as it\n              // happens after the .focus() call above.\n              // In this case, focus needs to be moved asynchronously.\n              restoreFocusFrame.request(() => {\n                floatingFocusElement.focus();\n              });\n              return;\n            }\n          }\n          const prevTabbableIndex = tabbableIndexRef.current;\n          const tabbableContent = getTabbableContent();\n          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;\n          if (isHTMLElement(nodeToFocus)) {\n            nodeToFocus.focus();\n          }\n        }\n\n        // https://github.com/floating-ui/floating-ui/issues/3060\n        if (dataRef.current.insideReactTree) {\n          dataRef.current.insideReactTree = false;\n          return;\n        }\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && (\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        // For an \"untrapped\" typeable combobox (input role=combobox with\n        // initialFocus=false), re-opening the popup and tabbing out should still close it even\n        // when the previously focused element (e.g. the next tabbable outside the popup) is\n        // focused again. Otherwise, the popup remains open on the second Tab sequence:\n        // click input -> Tab (closes) -> click input -> Tab.\n        // Allow closing when `isUntrappedTypeableCombobox` regardless of the previously focused element.\n        isUntrappedTypeableCombobox || relatedTarget !== getPreviouslyFocusedElement())) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, createChangeEventDetails('focus-out', event));\n        }\n      });\n    }\n    function markInsideReactTree() {\n      dataRef.current.insideReactTree = true;\n      blurTimeout.start(0, () => {\n        dataRef.current.insideReactTree = false;\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      floating.addEventListener('focusout', handleFocusOutside);\n      if (portalContext) {\n        floating.addEventListener('focusout', markInsideReactTree, true);\n      }\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        floating.removeEventListener('focusout', handleFocusOutside);\n        if (portalContext) {\n          floating.removeEventListener('focusout', markInsideReactTree, true);\n        }\n      };\n    }\n    return undefined;\n  }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef, dataRef, blurTimeout, pointerDownTimeout, restoreFocusFrame]);\n  const beforeGuardRef = React.useRef(null);\n  const afterGuardRef = React.useRef(null);\n  const mergedBeforeGuardRef = useMergedRefs(beforeGuardRef, portalContext?.beforeInsideRef);\n  const mergedAfterGuardRef = useMergedRefs(afterGuardRef, portalContext?.afterInsideRef);\n  React.useEffect(() => {\n    if (disabled || !floating || !open) {\n      return undefined;\n    }\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from(portalContext?.portalNode?.querySelectorAll(`[${createAttribute('portal')}]`) || []);\n    const ancestors = tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : [];\n    const rootAncestorComboboxDomReference = ancestors.find(node => isTypeableCombobox(node.context?.elements.domReference || null))?.context?.elements.domReference;\n    const insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext?.beforeOutsideRef.current, portalContext?.afterOutsideRef.current, isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n    const cleanup = markOthers(insideElements, modal || isUntrappedTypeableCombobox);\n    return () => {\n      cleanup();\n    };\n  }, [open, disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, tree, getNodeId, getInsideElements]);\n  useIsoLayoutEffect(() => {\n    if (disabled || !isHTMLElement(floatingFocusElement)) {\n      return;\n    }\n    const doc = getDocument(floatingFocusElement);\n    const previouslyFocusedElement = activeElement(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floatingFocusElement);\n      const initialFocusValueOrFn = initialFocusRef.current;\n      const resolvedInitialFocus = typeof initialFocusValueOrFn === 'function' ? initialFocusValueOrFn(openInteractionTypeRef.current || '') : initialFocusValueOrFn;\n\n      // `null` should fallback to default behavior in case of an empty ref.\n      if (resolvedInitialFocus === undefined || resolvedInitialFocus === false) {\n        return;\n      }\n      let elToFocus;\n      if (resolvedInitialFocus === true || resolvedInitialFocus === null) {\n        elToFocus = focusableElements[0] || floatingFocusElement;\n      } else if ('current' in resolvedInitialFocus) {\n        elToFocus = resolvedInitialFocus.current;\n      } else {\n        elToFocus = resolvedInitialFocus;\n      }\n      elToFocus = elToFocus || focusableElements[0] || floatingFocusElement;\n      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);\n      if (!focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floatingFocusElement\n        });\n      }\n    });\n  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef, openInteractionTypeRef]);\n  useIsoLayoutEffect(() => {\n    if (disabled || !floatingFocusElement) {\n      return undefined;\n    }\n    const doc = getDocument(floatingFocusElement);\n    const previouslyFocusedElement = activeElement(doc);\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChangeLocal(details) {\n      if (!details.open) {\n        closeTypeRef.current = getEventType(details.nativeEvent, lastInteractionTypeRef.current);\n      }\n      if (details.reason === 'trigger-hover' && details.nativeEvent.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (details.reason !== 'outside-press') {\n        return;\n      }\n      if (details.nested) {\n        preventReturnFocusRef.current = false;\n      } else if (isVirtualClick(details.nativeEvent) || isVirtualPointerEvent(details.nativeEvent)) {\n        preventReturnFocusRef.current = false;\n      } else {\n        let isPreventScrollSupported = false;\n        document.createElement('div').focus({\n          get preventScroll() {\n            isPreventScrollSupported = true;\n            return false;\n          }\n        });\n        if (isPreventScrollSupported) {\n          preventReturnFocusRef.current = false;\n        } else {\n          preventReturnFocusRef.current = true;\n        }\n      }\n    }\n    events.on('openchange', onOpenChangeLocal);\n    const fallbackEl = doc.createElement('span');\n    fallbackEl.setAttribute('tabindex', '-1');\n    fallbackEl.setAttribute('aria-hidden', 'true');\n    Object.assign(fallbackEl.style, visuallyHidden);\n    if (isInsidePortal && domReference) {\n      domReference.insertAdjacentElement('afterend', fallbackEl);\n    }\n    function getReturnElement() {\n      const returnFocusValueOrFn = returnFocusRef.current;\n      let resolvedReturnFocusValue = typeof returnFocusValueOrFn === 'function' ? returnFocusValueOrFn(closeTypeRef.current) : returnFocusValueOrFn;\n\n      // `null` should fallback to default behavior in case of an empty ref.\n      if (resolvedReturnFocusValue === undefined || resolvedReturnFocusValue === false) {\n        return null;\n      }\n      if (resolvedReturnFocusValue === null) {\n        resolvedReturnFocusValue = true;\n      }\n      if (typeof resolvedReturnFocusValue === 'boolean') {\n        const el = domReference || getPreviouslyFocusedElement();\n        return el && el.isConnected ? el : fallbackEl;\n      }\n      const fallback = domReference || getPreviouslyFocusedElement() || fallbackEl;\n      if ('current' in resolvedReturnFocusValue) {\n        return resolvedReturnFocusValue.current || fallback;\n      }\n      return resolvedReturnFocusValue || fallback;\n    }\n    return () => {\n      events.off('openchange', onOpenChangeLocal);\n      const activeEl = activeElement(doc);\n      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getNodeChildren(tree.nodesRef.current, getNodeId(), false).some(node => contains(node.context?.elements.floating, activeEl));\n      const returnElement = getReturnElement();\n      queueMicrotask(() => {\n        // This is `returnElement`, if it's tabbable, or its first tabbable child.\n        const tabbableReturnElement = getFirstTabbableElement(returnElement);\n        const hasExplicitReturnFocus = typeof returnFocusRef.current !== 'boolean';\n        if (\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(tabbableReturnElement) && (\n        // If the focus moved somewhere else after mount, avoid returning focus\n        // since it likely entered a different element which should be\n        // respected: https://github.com/floating-ui/floating-ui/issues/2607\n        !hasExplicitReturnFocus && tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n          tabbableReturnElement.focus({\n            preventScroll: true\n          });\n        }\n        fallbackEl.remove();\n      });\n    };\n  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events, tree, isInsidePortal, domReference, getNodeId]);\n  React.useEffect(() => {\n    // The `returnFocus` cleanup behavior is inside a microtask; ensure we\n    // wait for it to complete before resetting the flag.\n    queueMicrotask(() => {\n      preventReturnFocusRef.current = false;\n    });\n  }, [disabled]);\n  React.useEffect(() => {\n    if (disabled || !open) {\n      return undefined;\n    }\n    function handlePointerDown(event) {\n      const target = getTarget(event);\n      if (target?.closest(`[${CLICK_TRIGGER_IDENTIFIER}]`)) {\n        isPointerDownRef.current = true;\n      }\n    }\n    const doc = getDocument(floatingFocusElement);\n    doc.addEventListener('pointerdown', handlePointerDown, true);\n    return () => {\n      doc.removeEventListener('pointerdown', handlePointerDown, true);\n    };\n  }, [disabled, open, floatingFocusElement]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  useIsoLayoutEffect(() => {\n    if (disabled) {\n      return undefined;\n    }\n    if (!portalContext) {\n      return undefined;\n    }\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      domReference\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, closeOnFocusOut, domReference]);\n  useIsoLayoutEffect(() => {\n    if (disabled || !floatingFocusElement) {\n      return undefined;\n    }\n    handleTabIndex(floatingFocusElement, orderRef);\n    return () => {\n      queueMicrotask(clearDisconnectedPreviouslyFocusedElements);\n    };\n  }, [disabled, floatingFocusElement, orderRef]);\n  const shouldRenderGuards = !disabled && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [shouldRenderGuards && /*#__PURE__*/_jsx(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: mergedBeforeGuardRef,\n      onFocus: event => {\n        if (modal) {\n          const els = getTabbableElements();\n          enqueueFocus(els[els.length - 1]);\n        } else if (portalContext?.preserveTabOrder && portalContext.portalNode) {\n          preventReturnFocusRef.current = false;\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const nextTabbable = getNextTabbable(domReference);\n            nextTabbable?.focus();\n          } else {\n            portalContext.beforeOutsideRef.current?.focus();\n          }\n        }\n      }\n    }), children, shouldRenderGuards && /*#__PURE__*/_jsx(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: mergedAfterGuardRef,\n      onFocus: event => {\n        if (modal) {\n          enqueueFocus(getTabbableElements()[0]);\n        } else if (portalContext?.preserveTabOrder && portalContext.portalNode) {\n          if (closeOnFocusOut) {\n            preventReturnFocusRef.current = true;\n          }\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const prevTabbable = getPreviousTabbable(domReference);\n            prevTabbable?.focus();\n          } else {\n            portalContext.afterOutsideRef.current?.focus();\n          }\n        }\n      }\n    })]\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}