{"ast":null,"code":"import { isElement } from '@floating-ui/utils/dom';\nimport { Timeout } from '@base-ui-components/utils/useTimeout';\nimport { contains, getTarget } from \"./utils/element.js\";\nimport { getNodeChildren } from \"./utils/nodes.js\";\n\n/* eslint-disable no-nested-ternary */\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInsideValue = false;\n  const length = polygon.length;\n  // eslint-disable-next-line no-plusplus\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInsideValue = !isInsideValue;\n    }\n  }\n  return isInsideValue;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nexport function safePolygon(options = {}) {\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  const timeout = new Timeout();\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = typeof performance !== 'undefined' ? performance.now() : 0;\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = ({\n    x,\n    y,\n    placement,\n    elements,\n    onClose,\n    nodeId,\n    tree\n  }) => {\n    return function onMouseMove(event) {\n      function close() {\n        timeout.clear();\n        onClose();\n      }\n      timeout.clear();\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return undefined;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return undefined;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return undefined;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return undefined;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getNodeChildren(tree.nodesRef.current, nodeId).some(({\n        context\n      }) => context?.open)) {\n        return undefined;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n        default:\n      }\n      function getPolygon([px, py]) {\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer];\n              const cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [px + buffer + 1, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const cursorPointTwo = [px + buffer + 1, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [px - buffer, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const cursorPointTwo = [px - buffer, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          default:\n            return [];\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return undefined;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeout.start(40, close);\n      }\n      return undefined;\n    };\n  };\n\n  // eslint-disable-next-line no-underscore-dangle\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}","map":{"version":3,"names":["isElement","Timeout","contains","getTarget","getNodeChildren","isPointInPolygon","point","polygon","x","y","isInsideValue","length","i","j","xi","yi","xj","yj","intersect","isInside","rect","width","height","safePolygon","options","buffer","blockPointerEvents","requireIntent","timeout","hasLanded","lastX","lastY","lastCursorTime","performance","now","getCursorSpeed","currentTime","elapsedTime","deltaX","deltaY","distance","Math","sqrt","speed","fn","placement","elements","onClose","nodeId","tree","onMouseMove","event","close","clear","domReference","floating","undefined","clientX","clientY","clientPoint","target","isLeave","type","isOverFloatingEl","isOverReferenceEl","refRect","getBoundingClientRect","side","split","cursorLeaveFromRight","right","cursorLeaveFromBottom","bottom","isOverReferenceRect","isFloatingWider","isFloatingTaller","left","top","relatedTarget","nodesRef","current","some","context","open","rectPoly","getPolygon","px","py","cursorPointOne","cursorPointTwo","commonPoints","cursorSpeed","cursorSpeedThreshold","start","__options"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/floating-ui-react/safePolygon.js"],"sourcesContent":["import { isElement } from '@floating-ui/utils/dom';\nimport { Timeout } from '@base-ui-components/utils/useTimeout';\nimport { contains, getTarget } from \"./utils/element.js\";\nimport { getNodeChildren } from \"./utils/nodes.js\";\n\n/* eslint-disable no-nested-ternary */\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInsideValue = false;\n  const length = polygon.length;\n  // eslint-disable-next-line no-plusplus\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInsideValue = !isInsideValue;\n    }\n  }\n  return isInsideValue;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nexport function safePolygon(options = {}) {\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  const timeout = new Timeout();\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = typeof performance !== 'undefined' ? performance.now() : 0;\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = ({\n    x,\n    y,\n    placement,\n    elements,\n    onClose,\n    nodeId,\n    tree\n  }) => {\n    return function onMouseMove(event) {\n      function close() {\n        timeout.clear();\n        onClose();\n      }\n      timeout.clear();\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return undefined;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return undefined;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return undefined;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return undefined;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getNodeChildren(tree.nodesRef.current, nodeId).some(({\n        context\n      }) => context?.open)) {\n        return undefined;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n        default:\n      }\n      function getPolygon([px, py]) {\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? px + buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer];\n              const cursorPointTwo = [isFloatingWider ? px - buffer / 2 : cursorLeaveFromRight ? px + buffer * 4 : px - buffer * 4, py - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [px + buffer + 1, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const cursorPointTwo = [px + buffer + 1, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [px - buffer, isFloatingTaller ? py + buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const cursorPointTwo = [px - buffer, isFloatingTaller ? py - buffer / 2 : cursorLeaveFromBottom ? py + buffer * 4 : py - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          default:\n            return [];\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return undefined;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeout.start(40, close);\n      }\n      return undefined;\n    };\n  };\n\n  // eslint-disable-next-line no-underscore-dangle\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}