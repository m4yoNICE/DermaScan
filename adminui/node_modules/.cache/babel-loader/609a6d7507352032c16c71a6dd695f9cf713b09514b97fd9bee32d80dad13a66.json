{"ast":null,"code":"'use client';\n\nimport * as ReactDOM from 'react-dom';\nimport { useAnimationFrame } from '@base-ui-components/utils/useAnimationFrame';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\n\n/**\n * Executes a function once all animations have finished on the provided element.\n * @param elementOrRef - The element to watch for animations.\n * @param waitForNextTick - Whether to wait for the next tick before checking for animations.\n */\nexport function useAnimationsFinished(elementOrRef, waitForNextTick = false) {\n  const frame = useAnimationFrame();\n  return useEventCallback((fnToExecute,\n  /**\n   * An optional [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that\n   * can be used to abort `fnToExecute` before all the animations have finished.\n   * @default null\n   */\n  signal = null) => {\n    frame.cancel();\n    if (elementOrRef == null) {\n      return;\n    }\n    let element;\n    if ('current' in elementOrRef) {\n      if (elementOrRef.current == null) {\n        return;\n      }\n      element = elementOrRef.current;\n    } else {\n      element = elementOrRef;\n    }\n    if (typeof element.getAnimations !== 'function' || globalThis.BASE_UI_ANIMATIONS_DISABLED) {\n      fnToExecute();\n    } else {\n      frame.request(() => {\n        function exec() {\n          if (!element) {\n            return;\n          }\n          Promise.allSettled(element.getAnimations().map(anim => anim.finished)).then(() => {\n            if (signal != null && signal.aborted) {\n              return;\n            }\n            // Synchronously flush the unmounting of the component so that the browser doesn't\n            // paint: https://github.com/mui/base-ui/issues/979\n            ReactDOM.flushSync(fnToExecute);\n          });\n        }\n\n        // `open: true` animations need to wait for the next tick to be detected\n        if (waitForNextTick) {\n          frame.request(exec);\n        } else {\n          exec();\n        }\n      });\n    }\n  });\n}","map":{"version":3,"names":["ReactDOM","useAnimationFrame","useEventCallback","useAnimationsFinished","elementOrRef","waitForNextTick","frame","fnToExecute","signal","cancel","element","current","getAnimations","globalThis","BASE_UI_ANIMATIONS_DISABLED","request","exec","Promise","allSettled","map","anim","finished","then","aborted","flushSync"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/utils/useAnimationsFinished.js"],"sourcesContent":["'use client';\n\nimport * as ReactDOM from 'react-dom';\nimport { useAnimationFrame } from '@base-ui-components/utils/useAnimationFrame';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\n\n/**\n * Executes a function once all animations have finished on the provided element.\n * @param elementOrRef - The element to watch for animations.\n * @param waitForNextTick - Whether to wait for the next tick before checking for animations.\n */\nexport function useAnimationsFinished(elementOrRef, waitForNextTick = false) {\n  const frame = useAnimationFrame();\n  return useEventCallback((fnToExecute,\n  /**\n   * An optional [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that\n   * can be used to abort `fnToExecute` before all the animations have finished.\n   * @default null\n   */\n  signal = null) => {\n    frame.cancel();\n    if (elementOrRef == null) {\n      return;\n    }\n    let element;\n    if ('current' in elementOrRef) {\n      if (elementOrRef.current == null) {\n        return;\n      }\n      element = elementOrRef.current;\n    } else {\n      element = elementOrRef;\n    }\n    if (typeof element.getAnimations !== 'function' || globalThis.BASE_UI_ANIMATIONS_DISABLED) {\n      fnToExecute();\n    } else {\n      frame.request(() => {\n        function exec() {\n          if (!element) {\n            return;\n          }\n          Promise.allSettled(element.getAnimations().map(anim => anim.finished)).then(() => {\n            if (signal != null && signal.aborted) {\n              return;\n            }\n            // Synchronously flush the unmounting of the component so that the browser doesn't\n            // paint: https://github.com/mui/base-ui/issues/979\n            ReactDOM.flushSync(fnToExecute);\n          });\n        }\n\n        // `open: true` animations need to wait for the next tick to be detected\n        if (waitForNextTick) {\n          frame.request(exec);\n        } else {\n          exec();\n        }\n      });\n    }\n  });\n}"],"mappings":"AAAA,YAAY;;AAEZ,OAAO,KAAKA,QAAQ,MAAM,WAAW;AACrC,SAASC,iBAAiB,QAAQ,6CAA6C;AAC/E,SAASC,gBAAgB,QAAQ,4CAA4C;;AAE7E;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAACC,YAAY,EAAEC,eAAe,GAAG,KAAK,EAAE;EAC3E,MAAMC,KAAK,GAAGL,iBAAiB,CAAC,CAAC;EACjC,OAAOC,gBAAgB,CAAC,CAACK,WAAW;EACpC;AACF;AACA;AACA;AACA;EACEC,MAAM,GAAG,IAAI,KAAK;IAChBF,KAAK,CAACG,MAAM,CAAC,CAAC;IACd,IAAIL,YAAY,IAAI,IAAI,EAAE;MACxB;IACF;IACA,IAAIM,OAAO;IACX,IAAI,SAAS,IAAIN,YAAY,EAAE;MAC7B,IAAIA,YAAY,CAACO,OAAO,IAAI,IAAI,EAAE;QAChC;MACF;MACAD,OAAO,GAAGN,YAAY,CAACO,OAAO;IAChC,CAAC,MAAM;MACLD,OAAO,GAAGN,YAAY;IACxB;IACA,IAAI,OAAOM,OAAO,CAACE,aAAa,KAAK,UAAU,IAAIC,UAAU,CAACC,2BAA2B,EAAE;MACzFP,WAAW,CAAC,CAAC;IACf,CAAC,MAAM;MACLD,KAAK,CAACS,OAAO,CAAC,MAAM;QAClB,SAASC,IAAIA,CAAA,EAAG;UACd,IAAI,CAACN,OAAO,EAAE;YACZ;UACF;UACAO,OAAO,CAACC,UAAU,CAACR,OAAO,CAACE,aAAa,CAAC,CAAC,CAACO,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;YAChF,IAAId,MAAM,IAAI,IAAI,IAAIA,MAAM,CAACe,OAAO,EAAE;cACpC;YACF;YACA;YACA;YACAvB,QAAQ,CAACwB,SAAS,CAACjB,WAAW,CAAC;UACjC,CAAC,CAAC;QACJ;;QAEA;QACA,IAAIF,eAAe,EAAE;UACnBC,KAAK,CAACS,OAAO,CAACC,IAAI,CAAC;QACrB,CAAC,MAAM;UACLA,IAAI,CAAC,CAAC;QACR;MACF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}