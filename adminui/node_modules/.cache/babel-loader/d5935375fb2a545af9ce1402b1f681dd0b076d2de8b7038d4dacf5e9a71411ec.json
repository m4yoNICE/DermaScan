{"ast":null,"code":"import { floor } from '@floating-ui/utils';\nimport { stopEvent } from \"./event.js\";\nimport { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP } from \"./constants.js\";\nexport function isDifferentGridRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nexport function isIndexOutOfListBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nexport function getMinListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    disabledIndices\n  });\n}\nexport function getMaxListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nexport function findNonDisabledListIndex(listRef, {\n  startingIndex = -1,\n  decrement = false,\n  disabledIndices,\n  amount = 1\n} = {}) {\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= listRef.current.length - 1 && isListIndexDisabled(listRef, index, disabledIndices));\n  return index;\n}\nexport function getGridNavigatedIndex(listRef, {\n  event,\n  orientation,\n  loop,\n  rtl,\n  cols,\n  disabledIndices,\n  minIndex,\n  maxIndex,\n  prevIndex,\n  stopEvent: stop = false\n}) {\n  let nextIndex = prevIndex;\n\n  // ---------------------------------------------------------------------------\n  // Detect row structure based on DOM. This works when items are grouped inside\n  // elements that declare `role=\"row\"` (e.g., Combobox.Row). We build a matrix\n  // where each entry is the array of item indices for that visual row. The\n  // algorithm gracefully falls back to regular `cols`-based handling when no\n  // row structure can be detected.\n  // ---------------------------------------------------------------------------\n  const rows = [];\n  const rowIndexMap = {};\n  let hasRoleRow = false;\n  {\n    let currentRowEl = null;\n    let currentRowIndex = -1;\n    listRef.current.forEach((el, idx) => {\n      if (el == null) {\n        return;\n      }\n      const rowEl = el.closest('[role=\"row\"]');\n      if (rowEl) {\n        hasRoleRow = true;\n      }\n      if (rowEl !== currentRowEl || currentRowIndex === -1) {\n        currentRowEl = rowEl;\n        currentRowIndex += 1;\n        rows[currentRowIndex] = [];\n      }\n      rows[currentRowIndex].push(idx);\n      rowIndexMap[idx] = currentRowIndex;\n    });\n  }\n  const hasDomRows = hasRoleRow && rows.length > 0 && rows.some(row => row.length !== cols);\n  function navigateVertically(direction) {\n    if (!hasDomRows || prevIndex === -1) {\n      return undefined;\n    }\n    const currentRow = rowIndexMap[prevIndex];\n    if (currentRow == null) {\n      return undefined;\n    }\n    const colInRow = rows[currentRow].indexOf(prevIndex);\n    let nextRow = direction === 'up' ? currentRow - 1 : currentRow + 1;\n    if (loop) {\n      if (nextRow < 0) {\n        nextRow = rows.length - 1;\n      } else if (nextRow >= rows.length) {\n        nextRow = 0;\n      }\n    }\n    const visited = new Set();\n    while (nextRow >= 0 && nextRow < rows.length && !visited.has(nextRow)) {\n      visited.add(nextRow);\n      const targetRow = rows[nextRow];\n      if (targetRow.length === 0) {\n        nextRow = direction === 'up' ? nextRow - 1 : nextRow + 1;\n        continue;\n      }\n      const clampedCol = Math.min(colInRow, targetRow.length - 1);\n      // Start from the preferred column, fallback leftwards until first\n      // enabled item is found.\n      for (let col = clampedCol; col >= 0; col -= 1) {\n        const candidate = targetRow[col];\n        if (!isListIndexDisabled(listRef, candidate, disabledIndices)) {\n          return candidate;\n        }\n      }\n      // Row had no enabled items, move to next row in the same direction.\n      nextRow = direction === 'up' ? nextRow - 1 : nextRow + 1;\n      if (loop) {\n        if (nextRow < 0) {\n          nextRow = rows.length - 1;\n        } else if (nextRow >= rows.length) {\n          nextRow = 0;\n        }\n      }\n    }\n    return undefined;\n  }\n  if (event.key === ARROW_UP) {\n    const domBasedCandidate = navigateVertically('up');\n    if (domBasedCandidate !== undefined) {\n      if (stop) {\n        stopEvent(event);\n      }\n      nextIndex = domBasedCandidate;\n    } else {\n      // fallback to original logic\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex === -1) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: nextIndex,\n          amount: cols,\n          decrement: true,\n          disabledIndices\n        });\n        if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n          const col = prevIndex % cols;\n          const maxCol = maxIndex % cols;\n          const offset = maxIndex - (maxCol - col);\n          if (maxCol === col) {\n            nextIndex = maxIndex;\n          } else {\n            nextIndex = maxCol > col ? offset : offset - cols;\n          }\n        }\n      }\n      if (isIndexOutOfListBounds(listRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    const domBasedCandidate = navigateVertically('down');\n    if (domBasedCandidate !== undefined) {\n      if (stop) {\n        stopEvent(event);\n      }\n      nextIndex = domBasedCandidate;\n    } else {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex === -1) {\n        nextIndex = minIndex;\n      } else {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          amount: cols,\n          disabledIndices\n        });\n        if (loop && prevIndex + cols > maxIndex) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex % cols - cols,\n            amount: cols,\n            disabledIndices\n          });\n        }\n      }\n      if (isIndexOutOfListBounds(listRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = floor(prevIndex / cols);\n    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          decrement: true,\n          disabledIndices\n        });\n        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = floor(maxIndex / cols) === prevRow;\n    if (isIndexOutOfListBounds(listRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nexport function createGridCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach(({\n    width,\n    height\n  }, index) => {\n    if (width > cols) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`[Floating UI]: Invalid grid - item width at index ${index} is greater than grid columns`);\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i += 1) {\n        for (let j = 0; j < height; j += 1) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex += 1;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nexport function getGridCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) {\n    return -1;\n  }\n  const firstCellIndex = cellMap.indexOf(index);\n  const sizeItem = sizes[index];\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + sizeItem.width - 1;\n    case 'bl':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + (sizeItem.height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n    default:\n      return -1;\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nexport function getGridCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\nexport function isListIndexDisabled(listRef, index, disabledIndices) {\n  if (typeof disabledIndices === 'function') {\n    return disabledIndices(index);\n  }\n  if (disabledIndices) {\n    return disabledIndices.includes(index);\n  }\n  const element = listRef.current[index];\n  return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n}","map":{"version":3,"names":["floor","stopEvent","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","isDifferentGridRow","index","cols","prevRow","Math","isIndexOutOfListBounds","listRef","current","length","getMinListIndex","disabledIndices","findNonDisabledListIndex","getMaxListIndex","decrement","startingIndex","amount","isListIndexDisabled","getGridNavigatedIndex","event","orientation","loop","rtl","minIndex","maxIndex","prevIndex","stop","nextIndex","rows","rowIndexMap","hasRoleRow","currentRowEl","currentRowIndex","forEach","el","idx","rowEl","closest","push","hasDomRows","some","row","navigateVertically","direction","undefined","currentRow","colInRow","indexOf","nextRow","visited","Set","has","add","targetRow","clampedCol","min","col","candidate","key","domBasedCandidate","maxCol","offset","lastRow","createGridCellMap","sizes","dense","cellMap","startIndex","width","height","process","env","NODE_ENV","Error","itemPlaced","targetCells","i","j","every","cell","getGridCellIndexOfCorner","corner","firstCellIndex","sizeItem","lastIndexOf","getGridCellIndices","indices","flatMap","cellIndex","includes","element","hasAttribute","getAttribute"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/floating-ui-react/utils/composite.js"],"sourcesContent":["import { floor } from '@floating-ui/utils';\nimport { stopEvent } from \"./event.js\";\nimport { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP } from \"./constants.js\";\nexport function isDifferentGridRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nexport function isIndexOutOfListBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nexport function getMinListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    disabledIndices\n  });\n}\nexport function getMaxListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nexport function findNonDisabledListIndex(listRef, {\n  startingIndex = -1,\n  decrement = false,\n  disabledIndices,\n  amount = 1\n} = {}) {\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= listRef.current.length - 1 && isListIndexDisabled(listRef, index, disabledIndices));\n  return index;\n}\nexport function getGridNavigatedIndex(listRef, {\n  event,\n  orientation,\n  loop,\n  rtl,\n  cols,\n  disabledIndices,\n  minIndex,\n  maxIndex,\n  prevIndex,\n  stopEvent: stop = false\n}) {\n  let nextIndex = prevIndex;\n\n  // ---------------------------------------------------------------------------\n  // Detect row structure based on DOM. This works when items are grouped inside\n  // elements that declare `role=\"row\"` (e.g., Combobox.Row). We build a matrix\n  // where each entry is the array of item indices for that visual row. The\n  // algorithm gracefully falls back to regular `cols`-based handling when no\n  // row structure can be detected.\n  // ---------------------------------------------------------------------------\n  const rows = [];\n  const rowIndexMap = {};\n  let hasRoleRow = false;\n  {\n    let currentRowEl = null;\n    let currentRowIndex = -1;\n    listRef.current.forEach((el, idx) => {\n      if (el == null) {\n        return;\n      }\n      const rowEl = el.closest('[role=\"row\"]');\n      if (rowEl) {\n        hasRoleRow = true;\n      }\n      if (rowEl !== currentRowEl || currentRowIndex === -1) {\n        currentRowEl = rowEl;\n        currentRowIndex += 1;\n        rows[currentRowIndex] = [];\n      }\n      rows[currentRowIndex].push(idx);\n      rowIndexMap[idx] = currentRowIndex;\n    });\n  }\n  const hasDomRows = hasRoleRow && rows.length > 0 && rows.some(row => row.length !== cols);\n  function navigateVertically(direction) {\n    if (!hasDomRows || prevIndex === -1) {\n      return undefined;\n    }\n    const currentRow = rowIndexMap[prevIndex];\n    if (currentRow == null) {\n      return undefined;\n    }\n    const colInRow = rows[currentRow].indexOf(prevIndex);\n    let nextRow = direction === 'up' ? currentRow - 1 : currentRow + 1;\n    if (loop) {\n      if (nextRow < 0) {\n        nextRow = rows.length - 1;\n      } else if (nextRow >= rows.length) {\n        nextRow = 0;\n      }\n    }\n    const visited = new Set();\n    while (nextRow >= 0 && nextRow < rows.length && !visited.has(nextRow)) {\n      visited.add(nextRow);\n      const targetRow = rows[nextRow];\n      if (targetRow.length === 0) {\n        nextRow = direction === 'up' ? nextRow - 1 : nextRow + 1;\n        continue;\n      }\n      const clampedCol = Math.min(colInRow, targetRow.length - 1);\n      // Start from the preferred column, fallback leftwards until first\n      // enabled item is found.\n      for (let col = clampedCol; col >= 0; col -= 1) {\n        const candidate = targetRow[col];\n        if (!isListIndexDisabled(listRef, candidate, disabledIndices)) {\n          return candidate;\n        }\n      }\n      // Row had no enabled items, move to next row in the same direction.\n      nextRow = direction === 'up' ? nextRow - 1 : nextRow + 1;\n      if (loop) {\n        if (nextRow < 0) {\n          nextRow = rows.length - 1;\n        } else if (nextRow >= rows.length) {\n          nextRow = 0;\n        }\n      }\n    }\n    return undefined;\n  }\n  if (event.key === ARROW_UP) {\n    const domBasedCandidate = navigateVertically('up');\n    if (domBasedCandidate !== undefined) {\n      if (stop) {\n        stopEvent(event);\n      }\n      nextIndex = domBasedCandidate;\n    } else {\n      // fallback to original logic\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex === -1) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: nextIndex,\n          amount: cols,\n          decrement: true,\n          disabledIndices\n        });\n        if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n          const col = prevIndex % cols;\n          const maxCol = maxIndex % cols;\n          const offset = maxIndex - (maxCol - col);\n          if (maxCol === col) {\n            nextIndex = maxIndex;\n          } else {\n            nextIndex = maxCol > col ? offset : offset - cols;\n          }\n        }\n      }\n      if (isIndexOutOfListBounds(listRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    const domBasedCandidate = navigateVertically('down');\n    if (domBasedCandidate !== undefined) {\n      if (stop) {\n        stopEvent(event);\n      }\n      nextIndex = domBasedCandidate;\n    } else {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex === -1) {\n        nextIndex = minIndex;\n      } else {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          amount: cols,\n          disabledIndices\n        });\n        if (loop && prevIndex + cols > maxIndex) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex % cols - cols,\n            amount: cols,\n            disabledIndices\n          });\n        }\n      }\n      if (isIndexOutOfListBounds(listRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = floor(prevIndex / cols);\n    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n      if (stop) {\n        stopEvent(event);\n      }\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          decrement: true,\n          disabledIndices\n        });\n        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = floor(maxIndex / cols) === prevRow;\n    if (isIndexOutOfListBounds(listRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nexport function createGridCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach(({\n    width,\n    height\n  }, index) => {\n    if (width > cols) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`[Floating UI]: Invalid grid - item width at index ${index} is greater than grid columns`);\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i += 1) {\n        for (let j = 0; j < height; j += 1) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex += 1;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nexport function getGridCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) {\n    return -1;\n  }\n  const firstCellIndex = cellMap.indexOf(index);\n  const sizeItem = sizes[index];\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + sizeItem.width - 1;\n    case 'bl':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + (sizeItem.height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n    default:\n      return -1;\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nexport function getGridCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\nexport function isListIndexDisabled(listRef, index, disabledIndices) {\n  if (typeof disabledIndices === 'function') {\n    return disabledIndices(index);\n  }\n  if (disabledIndices) {\n    return disabledIndices.includes(index);\n  }\n  const element = listRef.current[index];\n  return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}