{"ast":null,"code":"import { mergeObjects } from '@base-ui-components/utils/mergeObjects';\nconst EMPTY_PROPS = {};\n\n/**\n * Merges multiple sets of React props. It follows the Object.assign pattern where the rightmost object's fields overwrite\n * the conflicting ones from others. This doesn't apply to event handlers, `className` and `style` props.\n * Event handlers are merged such that they are called in sequence (the rightmost one being called first),\n * and allows the user to prevent the subsequent event handlers from being\n * executed by attaching a `preventBaseUIHandler` method.\n * It also merges the `className` and `style` props, whereby the classes are concatenated\n * and the rightmost styles overwrite the subsequent ones.\n *\n * Props can either be provided as objects or as functions that take the previous props as an argument.\n * The function will receive the merged props up to that point (going from left to right):\n * so in the case of `(obj1, obj2, fn, obj3)`, `fn` will receive the merged props of `obj1` and `obj2`.\n * The function is responsible for chaining event handlers if needed (i.e. we don't run the merge logic).\n *\n * Event handlers returned by the functions are not automatically prevented when `preventBaseUIHandler` is called.\n * They must check `event.baseUIHandlerPrevented` themselves and bail out if it's true.\n *\n * @important **`ref` is not merged.**\n * @param props props to merge.\n * @returns the merged props.\n */\n/* eslint-disable id-denylist */\n\nexport function mergeProps(a, b, c, d, e) {\n  // We need to mutably own `merged`\n  let merged = {\n    ...resolvePropsGetter(a, EMPTY_PROPS)\n  };\n  if (b) {\n    merged = mergeOne(merged, b);\n  }\n  if (c) {\n    merged = mergeOne(merged, c);\n  }\n  if (d) {\n    merged = mergeOne(merged, d);\n  }\n  if (e) {\n    merged = mergeOne(merged, e);\n  }\n  return merged;\n}\n/* eslint-enable id-denylist */\n\nexport function mergePropsN(props) {\n  if (props.length === 0) {\n    return EMPTY_PROPS;\n  }\n  if (props.length === 1) {\n    return resolvePropsGetter(props[0], EMPTY_PROPS);\n  }\n\n  // We need to mutably own `merged`\n  let merged = {\n    ...resolvePropsGetter(props[0], EMPTY_PROPS)\n  };\n  for (let i = 1; i < props.length; i += 1) {\n    merged = mergeOne(merged, props[i]);\n  }\n  return merged;\n}\nfunction mergeOne(merged, inputProps) {\n  if (isPropsGetter(inputProps)) {\n    return inputProps(merged);\n  }\n  return mutablyMergeInto(merged, inputProps);\n}\n\n/**\n * Merges two sets of props. In case of conflicts, the external props take precedence.\n */\nfunction mutablyMergeInto(mergedProps, externalProps) {\n  if (!externalProps) {\n    return mergedProps;\n  }\n\n  // eslint-disable-next-line guard-for-in\n  for (const propName in externalProps) {\n    const externalPropValue = externalProps[propName];\n    switch (propName) {\n      case 'style':\n        {\n          mergedProps[propName] = mergeObjects(mergedProps.style, externalPropValue);\n          break;\n        }\n      case 'className':\n        {\n          mergedProps[propName] = mergeClassNames(mergedProps.className, externalPropValue);\n          break;\n        }\n      default:\n        {\n          if (isEventHandler(propName, externalPropValue)) {\n            mergedProps[propName] = mergeEventHandlers(mergedProps[propName], externalPropValue);\n          } else {\n            mergedProps[propName] = externalPropValue;\n          }\n        }\n    }\n  }\n  return mergedProps;\n}\nfunction isEventHandler(key, value) {\n  // This approach is more efficient than using a regex.\n  const code0 = key.charCodeAt(0);\n  const code1 = key.charCodeAt(1);\n  const code2 = key.charCodeAt(2);\n  return code0 === 111 /* o */ && code1 === 110 /* n */ && code2 >= 65 /* A */ && code2 <= 90 /* Z */ && (typeof value === 'function' || typeof value === 'undefined');\n}\nfunction isPropsGetter(inputProps) {\n  return typeof inputProps === 'function';\n}\nfunction resolvePropsGetter(inputProps, previousProps) {\n  if (isPropsGetter(inputProps)) {\n    return inputProps(previousProps);\n  }\n  return inputProps ?? EMPTY_PROPS;\n}\nfunction mergeEventHandlers(ourHandler, theirHandler) {\n  if (!theirHandler) {\n    return ourHandler;\n  }\n  if (!ourHandler) {\n    return theirHandler;\n  }\n  return event => {\n    if (isSyntheticEvent(event)) {\n      const baseUIEvent = event;\n      makeEventPreventable(baseUIEvent);\n      const result = theirHandler(baseUIEvent);\n      if (!baseUIEvent.baseUIHandlerPrevented) {\n        ourHandler?.(baseUIEvent);\n      }\n      return result;\n    }\n    const result = theirHandler(event);\n    ourHandler?.(event);\n    return result;\n  };\n}\nexport function makeEventPreventable(event) {\n  event.preventBaseUIHandler = () => {\n    event.baseUIHandlerPrevented = true;\n  };\n  return event;\n}\nexport function mergeClassNames(ourClassName, theirClassName) {\n  if (theirClassName) {\n    if (ourClassName) {\n      // eslint-disable-next-line prefer-template\n      return theirClassName + ' ' + ourClassName;\n    }\n    return theirClassName;\n  }\n  return ourClassName;\n}\nfunction isSyntheticEvent(event) {\n  return event != null && typeof event === 'object' && 'nativeEvent' in event;\n}","map":{"version":3,"names":["mergeObjects","EMPTY_PROPS","mergeProps","a","b","c","d","e","merged","resolvePropsGetter","mergeOne","mergePropsN","props","length","i","inputProps","isPropsGetter","mutablyMergeInto","mergedProps","externalProps","propName","externalPropValue","style","mergeClassNames","className","isEventHandler","mergeEventHandlers","key","value","code0","charCodeAt","code1","code2","previousProps","ourHandler","theirHandler","event","isSyntheticEvent","baseUIEvent","makeEventPreventable","result","baseUIHandlerPrevented","preventBaseUIHandler","ourClassName","theirClassName"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/merge-props/mergeProps.js"],"sourcesContent":["import { mergeObjects } from '@base-ui-components/utils/mergeObjects';\nconst EMPTY_PROPS = {};\n\n/**\n * Merges multiple sets of React props. It follows the Object.assign pattern where the rightmost object's fields overwrite\n * the conflicting ones from others. This doesn't apply to event handlers, `className` and `style` props.\n * Event handlers are merged such that they are called in sequence (the rightmost one being called first),\n * and allows the user to prevent the subsequent event handlers from being\n * executed by attaching a `preventBaseUIHandler` method.\n * It also merges the `className` and `style` props, whereby the classes are concatenated\n * and the rightmost styles overwrite the subsequent ones.\n *\n * Props can either be provided as objects or as functions that take the previous props as an argument.\n * The function will receive the merged props up to that point (going from left to right):\n * so in the case of `(obj1, obj2, fn, obj3)`, `fn` will receive the merged props of `obj1` and `obj2`.\n * The function is responsible for chaining event handlers if needed (i.e. we don't run the merge logic).\n *\n * Event handlers returned by the functions are not automatically prevented when `preventBaseUIHandler` is called.\n * They must check `event.baseUIHandlerPrevented` themselves and bail out if it's true.\n *\n * @important **`ref` is not merged.**\n * @param props props to merge.\n * @returns the merged props.\n */\n/* eslint-disable id-denylist */\n\nexport function mergeProps(a, b, c, d, e) {\n  // We need to mutably own `merged`\n  let merged = {\n    ...resolvePropsGetter(a, EMPTY_PROPS)\n  };\n  if (b) {\n    merged = mergeOne(merged, b);\n  }\n  if (c) {\n    merged = mergeOne(merged, c);\n  }\n  if (d) {\n    merged = mergeOne(merged, d);\n  }\n  if (e) {\n    merged = mergeOne(merged, e);\n  }\n  return merged;\n}\n/* eslint-enable id-denylist */\n\nexport function mergePropsN(props) {\n  if (props.length === 0) {\n    return EMPTY_PROPS;\n  }\n  if (props.length === 1) {\n    return resolvePropsGetter(props[0], EMPTY_PROPS);\n  }\n\n  // We need to mutably own `merged`\n  let merged = {\n    ...resolvePropsGetter(props[0], EMPTY_PROPS)\n  };\n  for (let i = 1; i < props.length; i += 1) {\n    merged = mergeOne(merged, props[i]);\n  }\n  return merged;\n}\nfunction mergeOne(merged, inputProps) {\n  if (isPropsGetter(inputProps)) {\n    return inputProps(merged);\n  }\n  return mutablyMergeInto(merged, inputProps);\n}\n\n/**\n * Merges two sets of props. In case of conflicts, the external props take precedence.\n */\nfunction mutablyMergeInto(mergedProps, externalProps) {\n  if (!externalProps) {\n    return mergedProps;\n  }\n\n  // eslint-disable-next-line guard-for-in\n  for (const propName in externalProps) {\n    const externalPropValue = externalProps[propName];\n    switch (propName) {\n      case 'style':\n        {\n          mergedProps[propName] = mergeObjects(mergedProps.style, externalPropValue);\n          break;\n        }\n      case 'className':\n        {\n          mergedProps[propName] = mergeClassNames(mergedProps.className, externalPropValue);\n          break;\n        }\n      default:\n        {\n          if (isEventHandler(propName, externalPropValue)) {\n            mergedProps[propName] = mergeEventHandlers(mergedProps[propName], externalPropValue);\n          } else {\n            mergedProps[propName] = externalPropValue;\n          }\n        }\n    }\n  }\n  return mergedProps;\n}\nfunction isEventHandler(key, value) {\n  // This approach is more efficient than using a regex.\n  const code0 = key.charCodeAt(0);\n  const code1 = key.charCodeAt(1);\n  const code2 = key.charCodeAt(2);\n  return code0 === 111 /* o */ && code1 === 110 /* n */ && code2 >= 65 /* A */ && code2 <= 90 /* Z */ && (typeof value === 'function' || typeof value === 'undefined');\n}\nfunction isPropsGetter(inputProps) {\n  return typeof inputProps === 'function';\n}\nfunction resolvePropsGetter(inputProps, previousProps) {\n  if (isPropsGetter(inputProps)) {\n    return inputProps(previousProps);\n  }\n  return inputProps ?? EMPTY_PROPS;\n}\nfunction mergeEventHandlers(ourHandler, theirHandler) {\n  if (!theirHandler) {\n    return ourHandler;\n  }\n  if (!ourHandler) {\n    return theirHandler;\n  }\n  return event => {\n    if (isSyntheticEvent(event)) {\n      const baseUIEvent = event;\n      makeEventPreventable(baseUIEvent);\n      const result = theirHandler(baseUIEvent);\n      if (!baseUIEvent.baseUIHandlerPrevented) {\n        ourHandler?.(baseUIEvent);\n      }\n      return result;\n    }\n    const result = theirHandler(event);\n    ourHandler?.(event);\n    return result;\n  };\n}\nexport function makeEventPreventable(event) {\n  event.preventBaseUIHandler = () => {\n    event.baseUIHandlerPrevented = true;\n  };\n  return event;\n}\nexport function mergeClassNames(ourClassName, theirClassName) {\n  if (theirClassName) {\n    if (ourClassName) {\n      // eslint-disable-next-line prefer-template\n      return theirClassName + ' ' + ourClassName;\n    }\n    return theirClassName;\n  }\n  return ourClassName;\n}\nfunction isSyntheticEvent(event) {\n  return event != null && typeof event === 'object' && 'nativeEvent' in event;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}