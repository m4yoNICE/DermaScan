{"ast":null,"code":"'use client';\n\nimport { useRefWithInit } from \"./useRefWithInit.js\";\nimport { useOnMount } from \"./useOnMount.js\";\n/** Unlike `setTimeout`, rAF doesn't guarantee a positive integer return value, so we can't have\n * a monomorphic `uint` type with `0` meaning empty.\n * See warning note at:\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame#return_value */\nconst EMPTY = null;\nlet LAST_RAF = globalThis.requestAnimationFrame;\nclass Scheduler {\n  /* This implementation uses an array as a backing data-structure for frame callbacks.\n   * It allows `O(1)` callback cancelling by inserting a `null` in the array, though it\n   * never calls the native `cancelAnimationFrame` if there are no frames left. This can\n   * be much more efficient if there is a call pattern that alterns as\n   * \"request-cancel-request-cancel-…\".\n   * But in the case of \"request-request-…-cancel-cancel-…\", it leaves the final animation\n   * frame to run anyway. We turn that frame into a `O(1)` no-op via `callbacksCount`. */\n\n  callbacks = (() => [])();\n  callbacksCount = 0;\n  nextId = 1;\n  startId = 1;\n  isScheduled = false;\n  tick = timestamp => {\n    this.isScheduled = false;\n    const currentCallbacks = this.callbacks;\n    const currentCallbacksCount = this.callbacksCount;\n\n    // Update these before iterating, callbacks could call `requestAnimationFrame` again.\n    this.callbacks = [];\n    this.callbacksCount = 0;\n    this.startId = this.nextId;\n    if (currentCallbacksCount > 0) {\n      for (let i = 0; i < currentCallbacks.length; i += 1) {\n        currentCallbacks[i]?.(timestamp);\n      }\n    }\n  };\n  request(fn) {\n    const id = this.nextId;\n    this.nextId += 1;\n    this.callbacks.push(fn);\n    this.callbacksCount += 1;\n\n    /* In a test environment with fake timers, a fake `requestAnimationFrame` can be called\n     * but there's no guarantee that the animation frame will actually run before the fake\n     * timers are teared, which leaves `isScheduled` set, but won't run our `tick()`. */\n    const didRAFChange = process.env.NODE_ENV === 'test' && LAST_RAF !== requestAnimationFrame && (LAST_RAF = requestAnimationFrame, true);\n    if (!this.isScheduled || didRAFChange) {\n      requestAnimationFrame(this.tick);\n      this.isScheduled = true;\n    }\n    return id;\n  }\n  cancel(id) {\n    const index = id - this.startId;\n    if (index < 0 || index >= this.callbacks.length) {\n      return;\n    }\n    this.callbacks[index] = null;\n    this.callbacksCount -= 1;\n  }\n}\nconst scheduler = new Scheduler();\nexport class AnimationFrame {\n  static create() {\n    return new AnimationFrame();\n  }\n  static request(fn) {\n    return scheduler.request(fn);\n  }\n  static cancel(id) {\n    return scheduler.cancel(id);\n  }\n  currentId = (() => EMPTY)();\n\n  /**\n   * Executes `fn` after `delay`, clearing any previously scheduled call.\n   */\n  request(fn) {\n    this.cancel();\n    this.currentId = scheduler.request(() => {\n      this.currentId = EMPTY;\n      fn();\n    });\n  }\n  cancel = () => {\n    if (this.currentId !== EMPTY) {\n      scheduler.cancel(this.currentId);\n      this.currentId = EMPTY;\n    }\n  };\n  disposeEffect = () => {\n    return this.cancel;\n  };\n}\n\n/**\n * A `requestAnimationFrame` with automatic cleanup and guard.\n */\nexport function useAnimationFrame() {\n  const timeout = useRefWithInit(AnimationFrame.create).current;\n  useOnMount(timeout.disposeEffect);\n  return timeout;\n}","map":{"version":3,"names":["useRefWithInit","useOnMount","EMPTY","LAST_RAF","globalThis","requestAnimationFrame","Scheduler","callbacks","callbacksCount","nextId","startId","isScheduled","tick","timestamp","currentCallbacks","currentCallbacksCount","i","length","request","fn","id","push","didRAFChange","process","env","NODE_ENV","cancel","index","scheduler","AnimationFrame","create","currentId","disposeEffect","useAnimationFrame","timeout","current"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/utils/esm/useAnimationFrame.js"],"sourcesContent":["'use client';\n\nimport { useRefWithInit } from \"./useRefWithInit.js\";\nimport { useOnMount } from \"./useOnMount.js\";\n/** Unlike `setTimeout`, rAF doesn't guarantee a positive integer return value, so we can't have\n * a monomorphic `uint` type with `0` meaning empty.\n * See warning note at:\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame#return_value */\nconst EMPTY = null;\nlet LAST_RAF = globalThis.requestAnimationFrame;\nclass Scheduler {\n  /* This implementation uses an array as a backing data-structure for frame callbacks.\n   * It allows `O(1)` callback cancelling by inserting a `null` in the array, though it\n   * never calls the native `cancelAnimationFrame` if there are no frames left. This can\n   * be much more efficient if there is a call pattern that alterns as\n   * \"request-cancel-request-cancel-…\".\n   * But in the case of \"request-request-…-cancel-cancel-…\", it leaves the final animation\n   * frame to run anyway. We turn that frame into a `O(1)` no-op via `callbacksCount`. */\n\n  callbacks = (() => [])();\n  callbacksCount = 0;\n  nextId = 1;\n  startId = 1;\n  isScheduled = false;\n  tick = timestamp => {\n    this.isScheduled = false;\n    const currentCallbacks = this.callbacks;\n    const currentCallbacksCount = this.callbacksCount;\n\n    // Update these before iterating, callbacks could call `requestAnimationFrame` again.\n    this.callbacks = [];\n    this.callbacksCount = 0;\n    this.startId = this.nextId;\n    if (currentCallbacksCount > 0) {\n      for (let i = 0; i < currentCallbacks.length; i += 1) {\n        currentCallbacks[i]?.(timestamp);\n      }\n    }\n  };\n  request(fn) {\n    const id = this.nextId;\n    this.nextId += 1;\n    this.callbacks.push(fn);\n    this.callbacksCount += 1;\n\n    /* In a test environment with fake timers, a fake `requestAnimationFrame` can be called\n     * but there's no guarantee that the animation frame will actually run before the fake\n     * timers are teared, which leaves `isScheduled` set, but won't run our `tick()`. */\n    const didRAFChange = process.env.NODE_ENV === 'test' && LAST_RAF !== requestAnimationFrame && (LAST_RAF = requestAnimationFrame, true);\n    if (!this.isScheduled || didRAFChange) {\n      requestAnimationFrame(this.tick);\n      this.isScheduled = true;\n    }\n    return id;\n  }\n  cancel(id) {\n    const index = id - this.startId;\n    if (index < 0 || index >= this.callbacks.length) {\n      return;\n    }\n    this.callbacks[index] = null;\n    this.callbacksCount -= 1;\n  }\n}\nconst scheduler = new Scheduler();\nexport class AnimationFrame {\n  static create() {\n    return new AnimationFrame();\n  }\n  static request(fn) {\n    return scheduler.request(fn);\n  }\n  static cancel(id) {\n    return scheduler.cancel(id);\n  }\n  currentId = (() => EMPTY)();\n\n  /**\n   * Executes `fn` after `delay`, clearing any previously scheduled call.\n   */\n  request(fn) {\n    this.cancel();\n    this.currentId = scheduler.request(() => {\n      this.currentId = EMPTY;\n      fn();\n    });\n  }\n  cancel = () => {\n    if (this.currentId !== EMPTY) {\n      scheduler.cancel(this.currentId);\n      this.currentId = EMPTY;\n    }\n  };\n  disposeEffect = () => {\n    return this.cancel;\n  };\n}\n\n/**\n * A `requestAnimationFrame` with automatic cleanup and guard.\n */\nexport function useAnimationFrame() {\n  const timeout = useRefWithInit(AnimationFrame.create).current;\n  useOnMount(timeout.disposeEffect);\n  return timeout;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}