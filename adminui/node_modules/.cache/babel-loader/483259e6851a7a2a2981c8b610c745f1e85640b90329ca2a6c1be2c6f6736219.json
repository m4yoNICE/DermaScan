{"ast":null,"code":"import * as React from 'react';\nimport { isHTMLElement } from '@floating-ui/utils/dom';\nimport { useLatestRef } from '@base-ui-components/utils/useLatestRef';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { activeElement, contains, getDocument, isTypeableCombobox, isVirtualClick, isVirtualPointerEvent, stopEvent, getFloatingFocusElement, isIndexOutOfListBounds, getMinListIndex, getMaxListIndex, getGridNavigatedIndex, isListIndexDisabled, createGridCellMap, getGridCellIndices, getGridCellIndexOfCorner, findNonDisabledListIndex } from \"../utils.js\";\nimport { useFloatingParentNodeId, useFloatingTree } from \"../components/FloatingTree.js\";\nimport { createChangeEventDetails } from \"../../utils/createBaseUIEventDetails.js\";\nimport { enqueueFocus } from \"../utils/enqueueFocus.js\";\nimport { ARROW_UP, ARROW_DOWN, ARROW_RIGHT, ARROW_LEFT } from \"../utils/constants.js\";\nexport const ESCAPE = 'Escape';\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl, cols) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  if (orientation === 'both' || orientation === 'horizontal' && cols && cols > 1) {\n    return key === ESCAPE;\n  }\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nexport function useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    elements\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: onNavigateProp = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    parentOrientation,\n    cols = 1,\n    scrollItemIntoView = true,\n    itemSizes,\n    dense = false,\n    id\n  } = props;\n  if (process.env.NODE_ENV !== 'production') {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn('`useListNavigation` looping must be enabled to allow escaping.');\n      }\n      if (!virtual) {\n        console.warn('`useListNavigation` must be virtual to allow escaping.');\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either \"horizontal\" or \"both\".');\n    }\n  }\n  const floatingFocusElement = getFloatingFocusElement(elements.floating);\n  const floatingFocusElementRef = useLatestRef(floatingFocusElement);\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  useIsoLayoutEffect(() => {\n    context.dataRef.current.orientation = orientation;\n  }, [context, orientation]);\n  const typeableComboboxReference = isTypeableCombobox(elements.domReference);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex ?? -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const onNavigate = useEventCallback(event => {\n    onNavigateProp(indexRef.current === -1 ? null : indexRef.current, event);\n  });\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!elements.floating);\n  const previousOpenRef = React.useRef(open);\n  const forceSyncFocusRef = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const focusItem = useEventCallback(() => {\n    function runFocus(item) {\n      if (virtual) {\n        tree?.events.emit('virtualfocus', item);\n      } else {\n        enqueueFocus(item, {\n          sync: forceSyncFocusRef.current,\n          preventScroll: true\n        });\n      }\n    }\n    const initialItem = listRef.current[indexRef.current];\n    const forceScrollIntoView = forceScrollIntoViewRef.current;\n    if (initialItem) {\n      runFocus(initialItem);\n    }\n    const scheduler = forceSyncFocusRef.current ? v => v() : requestAnimationFrame;\n    scheduler(() => {\n      const waitedItem = listRef.current[indexRef.current] || initialItem;\n      if (!waitedItem) {\n        return;\n      }\n      if (!initialItem) {\n        runFocus(waitedItem);\n      }\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions &&\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        waitedItem.scrollIntoView?.(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  useIsoLayoutEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && elements.floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate();\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current();\n    }\n  }, [enabled, open, elements.floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  useIsoLayoutEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    if (!open) {\n      forceSyncFocusRef.current = false;\n      return;\n    }\n    if (!elements.floating) {\n      return;\n    }\n    if (activeIndex == null) {\n      forceSyncFocusRef.current = false;\n      if (selectedIndexRef.current != null) {\n        return;\n      }\n\n      // Reset while the floating element was open (e.g. the list changed).\n      if (previousMountedRef.current) {\n        indexRef.current = -1;\n        focusItem();\n      }\n\n      // Initial sync.\n      if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n        let runs = 0;\n        const waitForListPopulated = () => {\n          if (listRef.current[0] == null) {\n            // Avoid letting the browser paint if possible on the first try,\n            // otherwise use rAF. Don't try more than twice, since something\n            // is wrong otherwise.\n            if (runs < 2) {\n              const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n              scheduler(waitForListPopulated);\n            }\n            runs += 1;\n          } else {\n            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinListIndex(listRef, disabledIndicesRef.current) : getMaxListIndex(listRef, disabledIndicesRef.current);\n            keyRef.current = null;\n            onNavigate();\n          }\n        };\n        waitForListPopulated();\n      }\n    } else if (!isIndexOutOfListBounds(listRef, activeIndex)) {\n      indexRef.current = activeIndex;\n      focusItem();\n      forceScrollIntoViewRef.current = false;\n    }\n  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  useIsoLayoutEffect(() => {\n    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = nodes.find(node => node.id === parentId)?.context?.elements.floating;\n    const activeEl = activeElement(getDocument(elements.floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, elements.floating, tree, parentId, virtual]);\n  useIsoLayoutEffect(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousOpenRef.current = open;\n    previousMountedRef.current = !!elements.floating;\n  });\n  useIsoLayoutEffect(() => {\n    if (!open) {\n      keyRef.current = null;\n      focusItemOnOpenRef.current = focusItemOnOpen;\n    }\n  }, [open, focusItemOnOpen]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(event) {\n      if (!latestOpenRef.current) {\n        return;\n      }\n      const index = listRef.current.indexOf(event.currentTarget);\n      if (index !== -1 && indexRef.current !== index) {\n        indexRef.current = index;\n        onNavigate(event);\n      }\n    }\n    const itemProps = {\n      onFocus(event) {\n        forceSyncFocusRef.current = true;\n        syncCurrentTarget(event);\n      },\n      onClick: ({\n        currentTarget\n      }) => currentTarget.focus({\n        preventScroll: true\n      }),\n      // Safari\n      onMouseMove(event) {\n        forceSyncFocusRef.current = true;\n        forceScrollIntoViewRef.current = false;\n        if (focusItemOnHover) {\n          syncCurrentTarget(event);\n        }\n      },\n      onPointerLeave(event) {\n        if (!isPointerModalityRef.current || event.pointerType === 'touch') {\n          return;\n        }\n        forceSyncFocusRef.current = true;\n        const relatedTarget = event.relatedTarget;\n        if (!focusItemOnHover || listRef.current.includes(relatedTarget)) {\n          return;\n        }\n        indexRef.current = -1;\n        onNavigate(event);\n        if (!virtual) {\n          floatingFocusElementRef.current?.focus({\n            preventScroll: true\n          });\n        }\n      }\n    };\n    return itemProps;\n  }, [latestOpenRef, floatingFocusElementRef, focusItemOnHover, listRef, onNavigate, virtual]);\n  const getParentOrientation = React.useCallback(() => {\n    return parentOrientation ?? tree?.nodesRef.current.find(node => node.id === parentId)?.context?.dataRef?.current.orientation;\n  }, [parentId, tree, parentOrientation]);\n  const commonOnKeyDown = useEventCallback(event => {\n    isPointerModalityRef.current = false;\n    forceSyncFocusRef.current = true;\n\n    // When composing a character, Chrome fires ArrowDown twice. Firefox/Safari\n    // don't appear to suffer from this. `event.isComposing` is avoided due to\n    // Safari not supporting it properly (although it's not needed in the first\n    // place for Safari, just avoiding any possible issues).\n    if (event.which === 229) {\n      return;\n    }\n\n    // If the floating element is animating out, ignore navigation. Otherwise,\n    // the `activeIndex` gets set to 0 despite not being open so the next time\n    // the user ArrowDowns, the first item won't be focused.\n    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {\n      return;\n    }\n    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {\n      // If the nested list's close key is also the parent navigation key,\n      // let the parent navigate. Otherwise, stop propagating the event.\n      if (!isMainOrientationKey(event.key, getParentOrientation())) {\n        stopEvent(event);\n      }\n      onOpenChange(false, createChangeEventDetails('list-navigation', event.nativeEvent));\n      if (isHTMLElement(elements.domReference)) {\n        if (virtual) {\n          tree?.events.emit('virtualfocus', elements.domReference);\n        } else {\n          elements.domReference.focus();\n        }\n      }\n      return;\n    }\n    const currentIndex = indexRef.current;\n    const minIndex = getMinListIndex(listRef, disabledIndices);\n    const maxIndex = getMaxListIndex(listRef, disabledIndices);\n    if (!typeableComboboxReference) {\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(event);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(event);\n      }\n    }\n\n    // Grid navigation.\n    if (cols > 1) {\n      const sizes = itemSizes || Array.from({\n        length: listRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = createGridCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !isListIndexDisabled(listRef, index, disabledIndices));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isListIndexDisabled(listRef, index, disabledIndices) ? cellIndex : foundIndex, -1);\n      const index = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        rtl,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getGridCellIndices([...((typeof disabledIndices !== 'function' ? disabledIndices : null) || listRef.current.map((_, listIndex) => isListIndexDisabled(listRef, listIndex, disabledIndices) ? listIndex : undefined)), undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getGridCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction\n        // we're moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        // eslint-disable-next-line no-nested-ternary\n        event.key === ARROW_DOWN ? 'bl' : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? 'tr' : 'tl'),\n        stopEvent: true\n      })];\n      if (index != null) {\n        indexRef.current = index;\n        onNavigate(event);\n      }\n      if (orientation === 'both') {\n        return;\n      }\n    }\n    if (isMainOrientationKey(event.key, orientation)) {\n      stopEvent(event);\n\n      // Reset the index if no item is focused.\n      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n        onNavigate(event);\n        return;\n      }\n      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n        if (loop) {\n          if (currentIndex >= maxIndex) {\n            if (allowEscape && currentIndex !== listRef.current.length) {\n              indexRef.current = -1;\n            } else {\n              // Give time for virtualizers to update the listRef.\n              forceSyncFocusRef.current = false;\n              indexRef.current = minIndex;\n            }\n          } else {\n            indexRef.current = findNonDisabledListIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          }\n        } else {\n          indexRef.current = Math.min(maxIndex, findNonDisabledListIndex(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          }));\n        }\n      } else if (loop) {\n        if (currentIndex <= minIndex) {\n          if (allowEscape && currentIndex !== -1) {\n            indexRef.current = listRef.current.length;\n          } else {\n            // Give time for virtualizers to update the listRef.\n            forceSyncFocusRef.current = false;\n            indexRef.current = maxIndex;\n          }\n        } else {\n          indexRef.current = findNonDisabledListIndex(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else {\n        indexRef.current = Math.max(minIndex, findNonDisabledListIndex(listRef, {\n          startingIndex: currentIndex,\n          decrement: true,\n          disabledIndices\n        }));\n      }\n      if (isIndexOutOfListBounds(listRef, indexRef.current)) {\n        indexRef.current = -1;\n      }\n      onNavigate(event);\n    }\n  });\n  const ariaActiveDescendantProp = React.useMemo(() => {\n    return virtual && open && hasActiveIndex && {\n      'aria-activedescendant': `${id}-${activeIndex}`\n    };\n  }, [virtual, open, hasActiveIndex, id, activeIndex]);\n  const floating = React.useMemo(() => {\n    return {\n      'aria-orientation': orientation === 'both' ? undefined : orientation,\n      ...(!typeableComboboxReference ? ariaActiveDescendantProp : {}),\n      onKeyDown(event) {\n        // Close submenu on Shift+Tab\n        if (event.key === 'Tab' && event.shiftKey && open && !virtual) {\n          stopEvent(event);\n          onOpenChange(false, createChangeEventDetails('list-navigation', event.nativeEvent));\n          if (isHTMLElement(elements.domReference)) {\n            elements.domReference.focus();\n          }\n          return;\n        }\n        commonOnKeyDown(event);\n      },\n      onPointerMove() {\n        isPointerModalityRef.current = true;\n      }\n    };\n  }, [ariaActiveDescendantProp, commonOnKeyDown, orientation, typeableComboboxReference, onOpenChange, open, virtual, elements.domReference]);\n  const reference = React.useMemo(() => {\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = !virtual;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    return {\n      ...ariaActiveDescendantProp,\n      onKeyDown(event) {\n        isPointerModalityRef.current = false;\n        const isArrowKey = event.key.startsWith('Arrow');\n        const isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl);\n        const isMainKey = isMainOrientationKey(event.key, orientation);\n        const isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n        if (virtual && open) {\n          return commonOnKeyDown(event);\n        }\n\n        // If a floating element should not open on arrow key down, avoid\n        // setting `activeIndex` while it's closed.\n        if (!open && !openOnArrowKeyDown && isArrowKey) {\n          return undefined;\n        }\n        if (isNavigationKey) {\n          const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());\n          keyRef.current = nested && isParentMainKey ? null : event.key;\n        }\n        if (nested) {\n          if (isParentCrossOpenKey) {\n            stopEvent(event);\n            if (open) {\n              indexRef.current = getMinListIndex(listRef, disabledIndicesRef.current);\n              onNavigate(event);\n            } else {\n              onOpenChange(true, createChangeEventDetails('list-navigation', event.nativeEvent));\n            }\n          }\n          return undefined;\n        }\n        if (isMainKey) {\n          if (selectedIndex != null) {\n            indexRef.current = selectedIndex;\n          }\n          stopEvent(event);\n          if (!open && openOnArrowKeyDown) {\n            onOpenChange(true, createChangeEventDetails('list-navigation', event.nativeEvent));\n          } else {\n            commonOnKeyDown(event);\n          }\n          if (open) {\n            onNavigate(event);\n          }\n        }\n        return undefined;\n      },\n      onFocus(event) {\n        if (open && !virtual) {\n          indexRef.current = -1;\n          onNavigate(event);\n        }\n      },\n      onPointerDown: checkVirtualPointer,\n      onPointerEnter: checkVirtualPointer,\n      onMouseDown: checkVirtualMouse,\n      onClick: checkVirtualMouse\n    };\n  }, [ariaActiveDescendantProp, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, getParentOrientation, rtl, selectedIndex, virtual]);\n  return React.useMemo(() => enabled ? {\n    reference,\n    floating,\n    item\n  } : {}, [enabled, reference, floating, item]);\n}","map":{"version":3,"names":["React","isHTMLElement","useLatestRef","useEventCallback","useIsoLayoutEffect","activeElement","contains","getDocument","isTypeableCombobox","isVirtualClick","isVirtualPointerEvent","stopEvent","getFloatingFocusElement","isIndexOutOfListBounds","getMinListIndex","getMaxListIndex","getGridNavigatedIndex","isListIndexDisabled","createGridCellMap","getGridCellIndices","getGridCellIndexOfCorner","findNonDisabledListIndex","useFloatingParentNodeId","useFloatingTree","createChangeEventDetails","enqueueFocus","ARROW_UP","ARROW_DOWN","ARROW_RIGHT","ARROW_LEFT","ESCAPE","doSwitch","orientation","vertical","horizontal","isMainOrientationKey","key","isMainOrientationToEndKey","rtl","isCrossOrientationOpenKey","isCrossOrientationCloseKey","cols","useListNavigation","context","props","open","onOpenChange","elements","listRef","activeIndex","onNavigate","onNavigateProp","enabled","selectedIndex","allowEscape","loop","nested","virtual","focusItemOnOpen","focusItemOnHover","openOnArrowKeyDown","disabledIndices","undefined","parentOrientation","scrollItemIntoView","itemSizes","dense","id","process","env","NODE_ENV","console","warn","floatingFocusElement","floating","floatingFocusElementRef","parentId","tree","dataRef","current","typeableComboboxReference","domReference","focusItemOnOpenRef","useRef","indexRef","keyRef","isPointerModalityRef","event","previousOnNavigateRef","previousMountedRef","previousOpenRef","forceSyncFocusRef","forceScrollIntoViewRef","disabledIndicesRef","latestOpenRef","scrollItemIntoViewRef","selectedIndexRef","focusItem","runFocus","item","events","emit","sync","preventScroll","initialItem","forceScrollIntoView","scheduler","v","requestAnimationFrame","waitedItem","scrollIntoViewOptions","shouldScrollIntoView","scrollIntoView","block","inline","runs","waitForListPopulated","queueMicrotask","nodes","nodesRef","parent","find","node","activeEl","treeContainsActiveEl","some","focus","hasActiveIndex","useMemo","syncCurrentTarget","index","indexOf","currentTarget","itemProps","onFocus","onClick","onMouseMove","onPointerLeave","pointerType","relatedTarget","includes","getParentOrientation","useCallback","commonOnKeyDown","which","nativeEvent","currentIndex","minIndex","maxIndex","sizes","Array","from","length","width","height","cellMap","minGridIndex","findIndex","maxGridIndex","reduce","foundIndex","cellIndex","map","itemIndex","_","listIndex","prevIndex","ownerDocument","startingIndex","Math","min","decrement","max","ariaActiveDescendantProp","onKeyDown","shiftKey","onPointerMove","reference","checkVirtualMouse","checkVirtualPointer","isArrowKey","startsWith","isParentCrossOpenKey","isMainKey","isNavigationKey","trim","isParentMainKey","onPointerDown","onPointerEnter","onMouseDown"],"sources":["C:/Users/james/Documents/DermaScan/adminui/node_modules/@base-ui-components/react/esm/floating-ui-react/hooks/useListNavigation.js"],"sourcesContent":["import * as React from 'react';\nimport { isHTMLElement } from '@floating-ui/utils/dom';\nimport { useLatestRef } from '@base-ui-components/utils/useLatestRef';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { activeElement, contains, getDocument, isTypeableCombobox, isVirtualClick, isVirtualPointerEvent, stopEvent, getFloatingFocusElement, isIndexOutOfListBounds, getMinListIndex, getMaxListIndex, getGridNavigatedIndex, isListIndexDisabled, createGridCellMap, getGridCellIndices, getGridCellIndexOfCorner, findNonDisabledListIndex } from \"../utils.js\";\nimport { useFloatingParentNodeId, useFloatingTree } from \"../components/FloatingTree.js\";\nimport { createChangeEventDetails } from \"../../utils/createBaseUIEventDetails.js\";\nimport { enqueueFocus } from \"../utils/enqueueFocus.js\";\nimport { ARROW_UP, ARROW_DOWN, ARROW_RIGHT, ARROW_LEFT } from \"../utils/constants.js\";\nexport const ESCAPE = 'Escape';\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl, cols) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  if (orientation === 'both' || orientation === 'horizontal' && cols && cols > 1) {\n    return key === ESCAPE;\n  }\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nexport function useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    elements\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: onNavigateProp = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    parentOrientation,\n    cols = 1,\n    scrollItemIntoView = true,\n    itemSizes,\n    dense = false,\n    id\n  } = props;\n  if (process.env.NODE_ENV !== 'production') {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn('`useListNavigation` looping must be enabled to allow escaping.');\n      }\n      if (!virtual) {\n        console.warn('`useListNavigation` must be virtual to allow escaping.');\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either \"horizontal\" or \"both\".');\n    }\n  }\n  const floatingFocusElement = getFloatingFocusElement(elements.floating);\n  const floatingFocusElementRef = useLatestRef(floatingFocusElement);\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  useIsoLayoutEffect(() => {\n    context.dataRef.current.orientation = orientation;\n  }, [context, orientation]);\n  const typeableComboboxReference = isTypeableCombobox(elements.domReference);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex ?? -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const onNavigate = useEventCallback(event => {\n    onNavigateProp(indexRef.current === -1 ? null : indexRef.current, event);\n  });\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!elements.floating);\n  const previousOpenRef = React.useRef(open);\n  const forceSyncFocusRef = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const focusItem = useEventCallback(() => {\n    function runFocus(item) {\n      if (virtual) {\n        tree?.events.emit('virtualfocus', item);\n      } else {\n        enqueueFocus(item, {\n          sync: forceSyncFocusRef.current,\n          preventScroll: true\n        });\n      }\n    }\n    const initialItem = listRef.current[indexRef.current];\n    const forceScrollIntoView = forceScrollIntoViewRef.current;\n    if (initialItem) {\n      runFocus(initialItem);\n    }\n    const scheduler = forceSyncFocusRef.current ? v => v() : requestAnimationFrame;\n    scheduler(() => {\n      const waitedItem = listRef.current[indexRef.current] || initialItem;\n      if (!waitedItem) {\n        return;\n      }\n      if (!initialItem) {\n        runFocus(waitedItem);\n      }\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions &&\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        waitedItem.scrollIntoView?.(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  useIsoLayoutEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && elements.floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate();\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current();\n    }\n  }, [enabled, open, elements.floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  useIsoLayoutEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    if (!open) {\n      forceSyncFocusRef.current = false;\n      return;\n    }\n    if (!elements.floating) {\n      return;\n    }\n    if (activeIndex == null) {\n      forceSyncFocusRef.current = false;\n      if (selectedIndexRef.current != null) {\n        return;\n      }\n\n      // Reset while the floating element was open (e.g. the list changed).\n      if (previousMountedRef.current) {\n        indexRef.current = -1;\n        focusItem();\n      }\n\n      // Initial sync.\n      if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n        let runs = 0;\n        const waitForListPopulated = () => {\n          if (listRef.current[0] == null) {\n            // Avoid letting the browser paint if possible on the first try,\n            // otherwise use rAF. Don't try more than twice, since something\n            // is wrong otherwise.\n            if (runs < 2) {\n              const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n              scheduler(waitForListPopulated);\n            }\n            runs += 1;\n          } else {\n            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinListIndex(listRef, disabledIndicesRef.current) : getMaxListIndex(listRef, disabledIndicesRef.current);\n            keyRef.current = null;\n            onNavigate();\n          }\n        };\n        waitForListPopulated();\n      }\n    } else if (!isIndexOutOfListBounds(listRef, activeIndex)) {\n      indexRef.current = activeIndex;\n      focusItem();\n      forceScrollIntoViewRef.current = false;\n    }\n  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  useIsoLayoutEffect(() => {\n    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = nodes.find(node => node.id === parentId)?.context?.elements.floating;\n    const activeEl = activeElement(getDocument(elements.floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, elements.floating, tree, parentId, virtual]);\n  useIsoLayoutEffect(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousOpenRef.current = open;\n    previousMountedRef.current = !!elements.floating;\n  });\n  useIsoLayoutEffect(() => {\n    if (!open) {\n      keyRef.current = null;\n      focusItemOnOpenRef.current = focusItemOnOpen;\n    }\n  }, [open, focusItemOnOpen]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(event) {\n      if (!latestOpenRef.current) {\n        return;\n      }\n      const index = listRef.current.indexOf(event.currentTarget);\n      if (index !== -1 && indexRef.current !== index) {\n        indexRef.current = index;\n        onNavigate(event);\n      }\n    }\n    const itemProps = {\n      onFocus(event) {\n        forceSyncFocusRef.current = true;\n        syncCurrentTarget(event);\n      },\n      onClick: ({\n        currentTarget\n      }) => currentTarget.focus({\n        preventScroll: true\n      }),\n      // Safari\n      onMouseMove(event) {\n        forceSyncFocusRef.current = true;\n        forceScrollIntoViewRef.current = false;\n        if (focusItemOnHover) {\n          syncCurrentTarget(event);\n        }\n      },\n      onPointerLeave(event) {\n        if (!isPointerModalityRef.current || event.pointerType === 'touch') {\n          return;\n        }\n        forceSyncFocusRef.current = true;\n        const relatedTarget = event.relatedTarget;\n        if (!focusItemOnHover || listRef.current.includes(relatedTarget)) {\n          return;\n        }\n        indexRef.current = -1;\n        onNavigate(event);\n        if (!virtual) {\n          floatingFocusElementRef.current?.focus({\n            preventScroll: true\n          });\n        }\n      }\n    };\n    return itemProps;\n  }, [latestOpenRef, floatingFocusElementRef, focusItemOnHover, listRef, onNavigate, virtual]);\n  const getParentOrientation = React.useCallback(() => {\n    return parentOrientation ?? tree?.nodesRef.current.find(node => node.id === parentId)?.context?.dataRef?.current.orientation;\n  }, [parentId, tree, parentOrientation]);\n  const commonOnKeyDown = useEventCallback(event => {\n    isPointerModalityRef.current = false;\n    forceSyncFocusRef.current = true;\n\n    // When composing a character, Chrome fires ArrowDown twice. Firefox/Safari\n    // don't appear to suffer from this. `event.isComposing` is avoided due to\n    // Safari not supporting it properly (although it's not needed in the first\n    // place for Safari, just avoiding any possible issues).\n    if (event.which === 229) {\n      return;\n    }\n\n    // If the floating element is animating out, ignore navigation. Otherwise,\n    // the `activeIndex` gets set to 0 despite not being open so the next time\n    // the user ArrowDowns, the first item won't be focused.\n    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {\n      return;\n    }\n    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {\n      // If the nested list's close key is also the parent navigation key,\n      // let the parent navigate. Otherwise, stop propagating the event.\n      if (!isMainOrientationKey(event.key, getParentOrientation())) {\n        stopEvent(event);\n      }\n      onOpenChange(false, createChangeEventDetails('list-navigation', event.nativeEvent));\n      if (isHTMLElement(elements.domReference)) {\n        if (virtual) {\n          tree?.events.emit('virtualfocus', elements.domReference);\n        } else {\n          elements.domReference.focus();\n        }\n      }\n      return;\n    }\n    const currentIndex = indexRef.current;\n    const minIndex = getMinListIndex(listRef, disabledIndices);\n    const maxIndex = getMaxListIndex(listRef, disabledIndices);\n    if (!typeableComboboxReference) {\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(event);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(event);\n      }\n    }\n\n    // Grid navigation.\n    if (cols > 1) {\n      const sizes = itemSizes || Array.from({\n        length: listRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = createGridCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !isListIndexDisabled(listRef, index, disabledIndices));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isListIndexDisabled(listRef, index, disabledIndices) ? cellIndex : foundIndex, -1);\n      const index = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        rtl,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getGridCellIndices([...((typeof disabledIndices !== 'function' ? disabledIndices : null) || listRef.current.map((_, listIndex) => isListIndexDisabled(listRef, listIndex, disabledIndices) ? listIndex : undefined)), undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getGridCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction\n        // we're moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        // eslint-disable-next-line no-nested-ternary\n        event.key === ARROW_DOWN ? 'bl' : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? 'tr' : 'tl'),\n        stopEvent: true\n      })];\n      if (index != null) {\n        indexRef.current = index;\n        onNavigate(event);\n      }\n      if (orientation === 'both') {\n        return;\n      }\n    }\n    if (isMainOrientationKey(event.key, orientation)) {\n      stopEvent(event);\n\n      // Reset the index if no item is focused.\n      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n        onNavigate(event);\n        return;\n      }\n      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n        if (loop) {\n          if (currentIndex >= maxIndex) {\n            if (allowEscape && currentIndex !== listRef.current.length) {\n              indexRef.current = -1;\n            } else {\n              // Give time for virtualizers to update the listRef.\n              forceSyncFocusRef.current = false;\n              indexRef.current = minIndex;\n            }\n          } else {\n            indexRef.current = findNonDisabledListIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          }\n        } else {\n          indexRef.current = Math.min(maxIndex, findNonDisabledListIndex(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          }));\n        }\n      } else if (loop) {\n        if (currentIndex <= minIndex) {\n          if (allowEscape && currentIndex !== -1) {\n            indexRef.current = listRef.current.length;\n          } else {\n            // Give time for virtualizers to update the listRef.\n            forceSyncFocusRef.current = false;\n            indexRef.current = maxIndex;\n          }\n        } else {\n          indexRef.current = findNonDisabledListIndex(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else {\n        indexRef.current = Math.max(minIndex, findNonDisabledListIndex(listRef, {\n          startingIndex: currentIndex,\n          decrement: true,\n          disabledIndices\n        }));\n      }\n      if (isIndexOutOfListBounds(listRef, indexRef.current)) {\n        indexRef.current = -1;\n      }\n      onNavigate(event);\n    }\n  });\n  const ariaActiveDescendantProp = React.useMemo(() => {\n    return virtual && open && hasActiveIndex && {\n      'aria-activedescendant': `${id}-${activeIndex}`\n    };\n  }, [virtual, open, hasActiveIndex, id, activeIndex]);\n  const floating = React.useMemo(() => {\n    return {\n      'aria-orientation': orientation === 'both' ? undefined : orientation,\n      ...(!typeableComboboxReference ? ariaActiveDescendantProp : {}),\n      onKeyDown(event) {\n        // Close submenu on Shift+Tab\n        if (event.key === 'Tab' && event.shiftKey && open && !virtual) {\n          stopEvent(event);\n          onOpenChange(false, createChangeEventDetails('list-navigation', event.nativeEvent));\n          if (isHTMLElement(elements.domReference)) {\n            elements.domReference.focus();\n          }\n          return;\n        }\n        commonOnKeyDown(event);\n      },\n      onPointerMove() {\n        isPointerModalityRef.current = true;\n      }\n    };\n  }, [ariaActiveDescendantProp, commonOnKeyDown, orientation, typeableComboboxReference, onOpenChange, open, virtual, elements.domReference]);\n  const reference = React.useMemo(() => {\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = !virtual;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    return {\n      ...ariaActiveDescendantProp,\n      onKeyDown(event) {\n        isPointerModalityRef.current = false;\n        const isArrowKey = event.key.startsWith('Arrow');\n        const isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl);\n        const isMainKey = isMainOrientationKey(event.key, orientation);\n        const isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n        if (virtual && open) {\n          return commonOnKeyDown(event);\n        }\n\n        // If a floating element should not open on arrow key down, avoid\n        // setting `activeIndex` while it's closed.\n        if (!open && !openOnArrowKeyDown && isArrowKey) {\n          return undefined;\n        }\n        if (isNavigationKey) {\n          const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());\n          keyRef.current = nested && isParentMainKey ? null : event.key;\n        }\n        if (nested) {\n          if (isParentCrossOpenKey) {\n            stopEvent(event);\n            if (open) {\n              indexRef.current = getMinListIndex(listRef, disabledIndicesRef.current);\n              onNavigate(event);\n            } else {\n              onOpenChange(true, createChangeEventDetails('list-navigation', event.nativeEvent));\n            }\n          }\n          return undefined;\n        }\n        if (isMainKey) {\n          if (selectedIndex != null) {\n            indexRef.current = selectedIndex;\n          }\n          stopEvent(event);\n          if (!open && openOnArrowKeyDown) {\n            onOpenChange(true, createChangeEventDetails('list-navigation', event.nativeEvent));\n          } else {\n            commonOnKeyDown(event);\n          }\n          if (open) {\n            onNavigate(event);\n          }\n        }\n        return undefined;\n      },\n      onFocus(event) {\n        if (open && !virtual) {\n          indexRef.current = -1;\n          onNavigate(event);\n        }\n      },\n      onPointerDown: checkVirtualPointer,\n      onPointerEnter: checkVirtualPointer,\n      onMouseDown: checkVirtualMouse,\n      onClick: checkVirtualMouse\n    };\n  }, [ariaActiveDescendantProp, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, getParentOrientation, rtl, selectedIndex, virtual]);\n  return React.useMemo(() => enabled ? {\n    reference,\n    floating,\n    item\n  } : {}, [enabled, reference, floating, item]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}